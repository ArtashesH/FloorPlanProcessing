#include <QFileDialog>
#include <QGraphicsView>
#include <QLineEdit>

#include <QComboBox>



#include <QMouseEvent>
#include <QGraphicsPixmapItem>
#include <QGraphicsItem>
#include <QDebug>
#include <QGraphicsSceneMouseEvent>
#include <QHeaderView>



//#include <Python.h>
#include <string>
#include <iostream>
#include <iomanip>
#include <map>
#include <fstream>



#include "floorplansegmentationgui.h"


cv::RNG rng(12345);


FloorPlanSegmentationGui::FloorPlanSegmentationGui(QWidget *parent)
	: QMainWindow(parent)
{


	std::string filename = "testHeightMapData.xml";
	cv::FileStorage fs(filename, cv::FileStorage::WRITE);
	fs.release();


	std::string filename2 = "testHeightMapDataThickness.xml";
	cv::FileStorage fs2(filename2, cv::FileStorage::WRITE);
	fs2.release();


	std::string filenameP = "testHeightMapDataParameters.xml";
	cv::FileStorage fsP(filenameP, cv::FileStorage::WRITE);
	fsP.release();


	std::string filenameA = "testHeightMapDataImproved.xml";
	cv::FileStorage fsA(filenameA, cv::FileStorage::WRITE);
	fsA.release();


	std::string filename1 = "testHeightMapDataAutoGenerated.xml";
	cv::FileStorage fs1(filename1, cv::FileStorage::WRITE);
	fs1.release();




	m_countOfHeightMapPoints = 0;
	m_mainWidget = new QWidget;
	m_segmentDataWidget = new QWidget;
	m_geoJsonWidget = new QDialog();
	m_geoJsonWidget->installEventFilter(this);
	m_isSelectedAxisPoint = false;


	m_materialsWidget = new QDialog();
	m_materialsWidget->installEventFilter(this);


	m_heightMapParamWidget = new QDialog();
	m_heightMapParamWidget->installEventFilter(this);


	m_wallDataWidget = new QDialog();
	m_wallDataWidget->installEventFilter(this);


	m_roomsWidget = new QDialog();
	m_roomsWidget->installEventFilter(this);

	m_accessPointsWidget = new QDialog();
	m_accessPointsWidget->installEventFilter(this);



	//QString filename = "E:/upworkProjs/FloorPlanAnalyzing/Venue_Images/TuckerStadium/APLayout.PNG";
	//QImage image(filename);

	m_mainGraphicsScene = new CustomScene();
	m_mainGraphicsScene->setSceneRect(0, 0, 1000, 1000);


	QPolygonF poly;
	poly << QPointF(10, 10) << QPointF(10, 50) << QPointF(30, 70) << QPointF(60, 50) << QPointF(50, 10);
	QBrush brush;
	brush.setColor(Qt::green);
	brush.setStyle(Qt::SolidPattern);
	
	QPen pen(Qt::green);
	QGraphicsScene graphics_scene_ = new QGraphicsScene(0, 0, 200, 200);
	//m_mainGraphicsScene->addPolygon(poly, pen, brush);
	//setScene(graphics_scene_);

	m_mainGraphicsView = new QGraphicsView(m_mainGraphicsScene);
	m_mainGraphicsView->setAlignment(Qt::AlignLeft | Qt::AlignTop);
	m_mainGraphicsView->setMouseTracking(true);

	
	m_selectImageButton = new QPushButton("Select Image");
//	m_selectImageButton->setFixedWidth(m_mainGraphicsScene->width() / 7);

	m_runSegmentationButton = new QPushButton("Run Segmentation");
//	m_runSegmentationButton->setFixedWidth(m_mainGraphicsScene->width() / 7);
	m_runSegmentationButton->setEnabled(false);



	m_runHeightMapGenerationButton = new QPushButton("Run HeighMap Generation");
//	m_runHeightMapGenerationButton->setFixedWidth(m_mainGraphicsScene->width() / 7);



	m_runHeightMapGenerationButton->setEnabled(false);

	m_runComponentsDetectionButton = new QPushButton("Run Components Detection");
//	m_runComponentsDetectionButton->setFixedWidth(m_mainGraphicsScene->width() / 7);



	m_runAccessPointDetectionButton = new QPushButton("Run Access Detection");
//	m_runAccessPointDetectionButton->setFixedWidth(m_mainGraphicsScene->width() / 7);
//	m_runAccessPointDetectionButton->setEnabled(false);



	m_runGeojsonGenerationButton = new QPushButton("Run Geojson");
	m_runGeojsonGenerationButton->setEnabled(false);
//	m_runGeojsonGenerationButton->setFixedWidth(m_mainGraphicsScene->width() / 7);

	m_selectLastSelectedWallButton = new QPushButton("GetLastPointWall");
	m_selectLastSelectedWallButton->setEnabled(true);

	m_selectLastSelectedWallLineButton = new QPushButton("GetLastWall");
	m_selectLastSelectedWallLineButton->setEnabled(true);


	m_runResetButton = new QPushButton("Reset");
	//m_runResetButton->setFixedWidth(m_mainGraphicsScene->width() / 7);
//	m_runResetButton->


	m_zoomDownButton = new QPushButton("Zoom Down");
	m_zoomUpButton = new QPushButton("Zoom Up");

	m_applyHeightMapData = new QPushButton("ApplyHeightMapSlection");
	m_applyHeightMapData->setEnabled(false);
	//m_applyHeightMapData->setFixedWidth(m_mainGraphicsScene->width() / 7);



	m_pixmapItem = new QGraphicsPixmapItem(/*QPixmap::fromImage(image)*/);
	m_mainGraphicsScene->addItem(m_pixmapItem);
	m_pixmapItem->setPos(0, 0);
	

	m_indexOfPolygonPoint = 0;




	m_roomNameLine = new QLineEdit;
	m_buildingNameLine = new QLineEdit;
	m_accessPointName = new QLineEdit;

	m_floorIDSpinbox = new QSpinBox;
	m_floorIDSpinbox->setMinimum(0);
	m_floorIDSpinbox->setSingleStep(1);


	m_accessPointID = new QSpinBox;
	m_accessPointID->setMinimum(0);
	m_accessPointID->setSingleStep(1);

//	m_lineForTypeOfRoom =  new QLineEdit;

	//m_segmentDataWidget->addAction(m_lineForTypeOfRoom);

	QVBoxLayout* layoutForGeojsonWidget = new QVBoxLayout;
	QVBoxLayout* layoutForWalllWidget = new QVBoxLayout;
	QVBoxLayout* layoutForRoomsWidget = new QVBoxLayout;
	QVBoxLayout* layoutForAccessPointsWidget = new QVBoxLayout;
	QVBoxLayout* layoutForHeightMapParameters = new QVBoxLayout;
	QVBoxLayout* layoutForCurrentWallData = new QVBoxLayout;
    


	QPushButton *btn1 = new QPushButton("Apply");
	QPushButton *btn2 = new QPushButton("Apply");
	QPushButton *btn3 = new QPushButton("Apply");
	QPushButton *btn4 = new QPushButton("Apply");
	QPushButton *btn5 = new QPushButton("Apply");
	QPushButton *btn6 = new QPushButton("Apply");

    m_tableWidgetGeojson = new QTableWidget;
	m_tableWidgetGeojson->setObjectName("ParametersTableWidget");
	m_tableWidgetGeojson->setRowCount(4);
	m_tableWidgetGeojson->setColumnCount(2);
	m_tableWidgetGeojson->setColumnWidth(0, 150);
	m_tableWidgetGeojson->setColumnWidth(1, 150);
	m_tableWidgetGeojson->setColumnWidth(2, 150);
	m_tableWidgetGeojson->setColumnWidth(3, 150);
//	m_tableWidget->setColumnWidth(4, 150);
	
	//m_tableWidget->setColumnWidth(6, 150);


	m_tableWidgetMaterial = new QTableWidget;
	m_tableWidgetMaterial->setObjectName("MaterialsTableWidget");
	m_tableWidgetMaterial->setRowCount(7);
	m_tableWidgetMaterial->setColumnCount(2);
	m_tableWidgetMaterial->setColumnWidth(0, 150);
	m_tableWidgetMaterial->setColumnWidth(1, 150);
	m_tableWidgetMaterial->setColumnWidth(2, 150);
	m_tableWidgetMaterial->setColumnWidth(3, 150);
	m_tableWidgetMaterial->setColumnWidth(4, 150);
	m_tableWidgetMaterial->setColumnWidth(5, 150);
	m_tableWidgetMaterial->setColumnWidth(6, 150);




	m_tableWidgetRooms = new QTableWidget;
	m_tableWidgetRooms->setObjectName("MaterialsTableWidget");
	m_tableWidgetRooms->setRowCount(4);
	m_tableWidgetRooms->setColumnCount(2);
	m_tableWidgetRooms->setColumnWidth(0, 150);
	m_tableWidgetRooms->setColumnWidth(1, 150);
	m_tableWidgetRooms->setColumnWidth(2, 150);
	


	m_tableWidgetAccessPoints = new QTableWidget;
	m_tableWidgetAccessPoints->setObjectName("AccessPointsTableWidget");
	m_tableWidgetAccessPoints->setRowCount(4);
	m_tableWidgetAccessPoints->setColumnCount(2);
	m_tableWidgetAccessPoints->setColumnWidth(0, 150);
	m_tableWidgetAccessPoints->setColumnWidth(1, 150);
	m_tableWidgetAccessPoints->setColumnWidth(2, 150);
	m_tableWidgetAccessPoints->setColumnWidth(3, 150);

	m_tableWidgetHeightMapData = new QTableWidget;
	m_tableWidgetHeightMapData->setObjectName("HeightMapTableWidget");
	m_tableWidgetHeightMapData->setRowCount(5);
	m_tableWidgetHeightMapData->setColumnCount(2);
	m_tableWidgetHeightMapData->setColumnWidth(0, 150);
	m_tableWidgetHeightMapData->setColumnWidth(1, 150);
	m_tableWidgetHeightMapData->setColumnWidth(2, 150);
	m_tableWidgetHeightMapData->setColumnWidth(3, 150);
	m_tableWidgetHeightMapData->setColumnWidth(4, 150);


	m_tableWidgetForWallData = new QTableWidget;
	m_tableWidgetForWallData->setObjectName("WallDataTableWidget");
	m_tableWidgetForWallData->setRowCount(3);
	m_tableWidgetForWallData->setColumnCount(2);
	m_tableWidgetForWallData->setColumnWidth(0, 150);
	m_tableWidgetForWallData->setColumnWidth(1, 150);
	m_tableWidgetForWallData->setColumnWidth(2, 150);








	m_DbmShowingButton = new QCheckBox("Show Dbm values");
	m_SinrShowingButton = new QCheckBox("Show Sinr values");
	m_contourShowingButton = new QCheckBox("Show HeightMap Contour");
	m_isDbmBoxChecked = false;
	m_isSinrBoxChecked = false;
	m_previousZoomValue = 100;

	m_selectComponentWidget = new QComboBox();
	m_selectComponentWidget->setFixedSize(100, 25);
	m_selectComponentWidget->addItem("Room");
	m_selectComponentWidget->addItem("Window");
	m_selectComponentWidget->addItem("Door");
	m_selectComponentWidget->addItem("Wall");
	m_selectComponentWidget->addItem("HeightMap");
	m_selectComponentWidget->addItem("Geojson");
	m_selectComponentWidget->addItem("AccessPoint");
	
	


	m_wallColorComboBox = new QComboBox();
	m_wallColorComboBox->addItem("Green");
	m_wallColorComboBox->addItem("Yellow");
	m_wallColorComboBox->addItem("Red");
	m_wallColorComboBox->addItem("Gray");
	m_wallColorComboBox->addItem("Black");
	m_wallColorComboBox->addItem("Blue");
	m_wallColorComboBox->addItem("DarkRed");
	m_wallColorComboBox->addItem("DarkGreen");
	m_wallColorComboBox->addItem("DarkBlue");
	m_wallColorComboBox->addItem("DarkYellow");






	m_roomColorComboBox = new QComboBox();
	m_roomColorComboBox->addItem("Green");
	m_roomColorComboBox->addItem("Yellow");
	m_roomColorComboBox->addItem("Red");
	m_roomColorComboBox->addItem("Gray");
	m_roomColorComboBox->addItem("Black");
	m_roomColorComboBox->addItem("Blue");
	m_roomColorComboBox->addItem("DarkRed");
	m_roomColorComboBox->addItem("DarkGreen");
	m_roomColorComboBox->addItem("DarkBlue");
	m_roomColorComboBox->addItem("DarkYellow");
	

	m_accessPointColorComboBox = new QComboBox();
	m_accessPointColorComboBox->addItem("Green");
	m_accessPointColorComboBox->addItem("Yellow");
	m_accessPointColorComboBox->addItem("Red");
	m_accessPointColorComboBox->addItem("Gray");
	m_accessPointColorComboBox->addItem("Black");
	m_accessPointColorComboBox->addItem("Blue");
	m_accessPointColorComboBox->addItem("DarkRed");
	m_accessPointColorComboBox->addItem("DarkGreen");
	m_accessPointColorComboBox->addItem("DarkBlue");
	m_accessPointColorComboBox->addItem("DarkYellow");


	m_modelForHeightMapComboBox = new QComboBox();
	m_modelForHeightMapComboBox->addItem("Path Loss Model");
	m_modelForHeightMapComboBox->addItem("Ray Tracing Model ");


	/*m_roomColorComboBox = new QComboBox();
	m_roomColorComboBox->addItem("Green");
	m_roomColorComboBox->addItem("Yellow");
	m_roomColorComboBox->addItem("Red");
	m_roomColorComboBox->addItem("Gray");
	m_roomColorComboBox->addItem("Black");
	m_roomColorComboBox->addItem("Blue");
	m_roomColorComboBox->addItem("DarkRed");
	m_roomColorComboBox->addItem("DarkGreen");
	m_roomColorComboBox->addItem("DarkBlue");
	m_roomColorComboBox->addItem("DarkYellow");*/



//	m_rotationAngleSpinBox = new QSpinBox();
//	m_rotationAngleSpinBox->setMinimum(-360);
//	m_rotationAngleSpinBox->setMaximum(360);


	m_latitudeSpinBox1 = new QDoubleSpinBox();
	m_latitudeSpinBox1->setDecimals(20);
	m_latitudeSpinBox1->setMinimum(-1000);;
	m_latitudeSpinBox1->setMaximum(1000);

	m_latitudeSpinBox2 = new QDoubleSpinBox();
	m_latitudeSpinBox2->setDecimals(20);
	m_latitudeSpinBox2->setMinimum(-1000);;
	m_latitudeSpinBox2->setMaximum(1000);


	
	m_longtitudeSpinBox1 = new QDoubleSpinBox();
	m_longtitudeSpinBox1->setDecimals(20);
	m_longtitudeSpinBox1->setMinimum(-1000);
	m_longtitudeSpinBox1->setMaximum(1000);



	m_longtitudeSpinBox2 = new QDoubleSpinBox();
	m_longtitudeSpinBox2->setDecimals(20);
	m_longtitudeSpinBox2->setMinimum(-1000);
	m_longtitudeSpinBox2->setMaximum(1000);



	m_scaleValueSpinBoxX = new QDoubleSpinBox();
	m_scaleValueSpinBoxY = new QDoubleSpinBox();
	
	m_rayFreqSpinBox = new QDoubleSpinBox();
	m_rayFreqSpinBox->setMinimum(0);
	m_rayFreqSpinBox->setSingleStep(0.1);

	m_pixelPerMeterScaleSpinBox = new QDoubleSpinBox();
	m_pixelPerMeterScaleSpinBox->setMinimum(0.1);
	m_pixelPerMeterScaleSpinBox->setSingleStep(0.1);


	m_thicknessOfWallSpinBox = new QDoubleSpinBox();
	m_thicknessOfWallSpinBox->setMinimum(0.1);
	m_thicknessOfWallSpinBox->setSingleStep(0.1);
	m_thicknessOfWallSpinBox->setValue(1);


	m_materialIDSpinBox = new QSpinBox();
	m_materialIDSpinBox->setMinimum(0);
	m_materialIDSpinBox->setSingleStep(1);


	m_countOfRaysSpinBox = new QSpinBox();
	m_countOfRaysSpinBox->setMinimum(0);
	m_countOfRaysSpinBox->setSingleStep(1);
	m_countOfRaysSpinBox->setMaximum(10000);


	m_deviceAlignmentSpinBox = new QSpinBox();
	m_deviceAlignmentSpinBox->setMinimum(0);
	m_deviceAlignmentSpinBox->setSingleStep(1);
	m_deviceAlignmentSpinBox->setMaximum(360);



	m_materialTicknessSpinBox = new QSpinBox();
	m_materialTicknessSpinBox->setMinimum(0);
	m_materialTicknessSpinBox->setSingleStep(1);


	m_wallHeightSpinBox = new QDoubleSpinBox();
	m_wallHeightSpinBox->setMinimum(0);
	m_wallHeightSpinBox->setSingleStep(0.1);
	m_wallHeightSpinBox->setMaximum(100);
	m_wallHeightSpinBox->setValue(0);



	m_accessPointHeightSpinBox = new QDoubleSpinBox();
	m_accessPointHeightSpinBox->setMinimum(0);
	m_accessPointHeightSpinBox->setSingleStep(0.1);
	m_accessPointHeightSpinBox->setMaximum(100);
	m_accessPointHeightSpinBox->setValue(0);

	m_zoomOptionSpinBox = new QSpinBox();
	m_zoomOptionSpinBox->setMinimum(10);
	m_zoomOptionSpinBox->setMaximum(300);
	m_zoomOptionSpinBox->setValue(100);
	m_zoomOptionSpinBox->setSingleStep(10);




	m_materialTypeComboBox = new QComboBox();
	m_materialTypeComboBox->addItem("Exterior Wall");
	m_materialTypeComboBox->addItem("Interior Wall");
	m_materialTypeComboBox->addItem("Window");
	m_materialTypeComboBox->addItem("Door");


	m_materialNameComboBox = new QComboBox();
	m_materialNameComboBox->addItem("Glass");
	m_materialNameComboBox->addItem("Low Energy Glass");
	m_materialNameComboBox->addItem("Concrete");
	m_materialNameComboBox->addItem("Small Brick Wal");
	m_materialNameComboBox->addItem("Stee");
	m_materialNameComboBox->addItem("Plaster Board");


	m_automatedDetectionAlgCombobox = new QComboBox();
	m_automatedDetectionAlgCombobox->addItem("Outer Wall");
	m_automatedDetectionAlgCombobox->addItem("Innner Wall");
	m_automatedDetectionAlgCombobox->addItem("Aggressive Wall");



	//QTableWidgetItem *item = new QTableWidgetItem("Color", QTableWidgetItem::Type);
	//item->setFlags(item->flags() ^ Qt::ItemIsEditable);
	//m_tableWidgetGeojson->setItem(0, 0, item);
	//m_tableWidgetGeojson->setCellWidget(0, 1, m_roomColorComboBox);



	QTableWidgetItem *itemMat = new QTableWidgetItem("Color", QTableWidgetItem::Type);
	itemMat->setFlags(itemMat->flags() ^ Qt::ItemIsEditable);
	m_tableWidgetMaterial->setItem(0, 0, itemMat); 
	m_tableWidgetMaterial->setCellWidget(0, 1, m_wallColorComboBox);
	

	

	QTableWidgetItem *itemRoom = new QTableWidgetItem("Color", QTableWidgetItem::Type);
	itemRoom->setFlags(itemRoom->flags() ^ Qt::ItemIsEditable);
	m_tableWidgetRooms->setItem(0, 0, itemRoom);
	m_tableWidgetRooms->setCellWidget(0, 1, m_roomColorComboBox);


	QTableWidgetItem *itemAccessPoint = new QTableWidgetItem("Color", QTableWidgetItem::Type);
	itemAccessPoint->setFlags(itemAccessPoint->flags() ^ Qt::ItemIsEditable);
	m_tableWidgetAccessPoints->setItem(0, 0, itemAccessPoint);
	m_tableWidgetAccessPoints->setCellWidget(0, 1, m_accessPointColorComboBox);

	QTableWidgetItem *itemHeightMapParamFreq = new QTableWidgetItem("Ray Freq", QTableWidgetItem::Type);
	itemHeightMapParamFreq->setFlags(itemHeightMapParamFreq->flags() ^ Qt::ItemIsEditable);
	
	m_tableWidgetHeightMapData->setItem(0, 0, itemHeightMapParamFreq);
	m_tableWidgetHeightMapData->setCellWidget(0, 1, m_rayFreqSpinBox);




	QTableWidgetItem *itemHeightMapParamRayCount = new QTableWidgetItem("Rays Count", QTableWidgetItem::Type);
	itemHeightMapParamRayCount->setFlags(itemHeightMapParamRayCount->flags() ^ Qt::ItemIsEditable);
	m_tableWidgetHeightMapData->setItem(1, 0, itemHeightMapParamRayCount);
	m_tableWidgetHeightMapData->setCellWidget(1, 1, m_countOfRaysSpinBox);



	QTableWidgetItem *itemHeightMapParamDeviceAlignment = new QTableWidgetItem("Device Aignment", QTableWidgetItem::Type);
	itemHeightMapParamDeviceAlignment->setFlags(itemHeightMapParamDeviceAlignment->flags() ^ Qt::ItemIsEditable);
	m_tableWidgetHeightMapData->setItem(4, 0, itemHeightMapParamDeviceAlignment);
	m_tableWidgetHeightMapData->setCellWidget(4, 1, m_deviceAlignmentSpinBox);






	QTableWidgetItem *itemHeightMapParamPixelPerMeterScale = new QTableWidgetItem("Pixel to Meter Scale", QTableWidgetItem::Type);
	itemHeightMapParamPixelPerMeterScale->setFlags(itemHeightMapParamPixelPerMeterScale->flags() ^ Qt::ItemIsEditable);
	m_tableWidgetHeightMapData->setItem(2, 0, itemHeightMapParamPixelPerMeterScale);
	m_tableWidgetHeightMapData->setCellWidget(2, 1, m_pixelPerMeterScaleSpinBox);




	QTableWidgetItem *itemHeightMapParamLossModel = new QTableWidgetItem("Loss Model", QTableWidgetItem::Type);
	itemHeightMapParamLossModel->setFlags(itemHeightMapParamLossModel->flags() ^ Qt::ItemIsEditable);
	m_tableWidgetHeightMapData->setItem(3, 0, itemHeightMapParamLossModel);
	m_tableWidgetHeightMapData->setCellWidget(3, 1, m_modelForHeightMapComboBox);


	QTableWidgetItem *itemWallThicknessCurrent = new QTableWidgetItem("Wall Thickness", QTableWidgetItem::Type);
	itemWallThicknessCurrent->setFlags(itemWallThicknessCurrent->flags() ^ Qt::ItemIsEditable);
	m_tableWidgetForWallData->setItem(0, 0, itemWallThicknessCurrent);
	m_tableWidgetForWallData->setCellWidget(0, 1, m_thicknessOfWallSpinBox);









	QTableWidgetItem *item1Mat = new QTableWidgetItem("Material Type", QTableWidgetItem::Type);
	m_tableWidgetMaterial->setMinimumWidth(500);
	item1Mat->setFlags(item1Mat->flags() ^ Qt::ItemIsEditable);
	m_tableWidgetMaterial->setItem(1, 0, item1Mat);
	m_tableWidgetMaterial->setCellWidget(1, 1, m_materialTypeComboBox);


	QTableWidgetItem *item1Room = new QTableWidgetItem("Floor ID", QTableWidgetItem::Type);
	m_tableWidgetRooms->setMinimumWidth(500);
	item1Room->setFlags(item1Room->flags() ^ Qt::ItemIsEditable);
	m_tableWidgetRooms->setItem(1, 0, item1Room);
	m_tableWidgetRooms->setCellWidget(1, 1, m_floorIDSpinbox);


	QTableWidgetItem *item1AccessPoint = new QTableWidgetItem("Access Point ID", QTableWidgetItem::Type);
	m_tableWidgetAccessPoints->setMinimumWidth(500);
	item1AccessPoint->setFlags(item1AccessPoint->flags() ^ Qt::ItemIsEditable);
	m_tableWidgetAccessPoints->setItem(1, 0, item1AccessPoint);
	m_tableWidgetAccessPoints->setCellWidget(1, 1, m_accessPointID);

	//QTableWidgetItem *item1Mat = new QTableWidgetItem("Name of Room", QTableWidgetItem::Type);
	//item1Mat->setFlags(item1Mat->flags() ^ Qt::ItemIsEditable);
	//m_tableWidgetMaterial->setItem(1, 0, item1Mat);

	
	QTableWidgetItem *item1 = new QTableWidgetItem("Initial Longtitude1", QTableWidgetItem::Type);
	m_tableWidgetGeojson->setMinimumWidth(500);
	item1->setFlags(item1->flags() ^ Qt::ItemIsEditable);
	m_tableWidgetGeojson->setItem(0, 0, item1);
	m_tableWidgetGeojson->setCellWidget(0, 1, m_longtitudeSpinBox1);




	QTableWidgetItem *item3Mat = new QTableWidgetItem("Material ID", QTableWidgetItem::Type);
	m_tableWidgetMaterial->setMinimumWidth(500);
	item3Mat->setFlags(item3Mat->flags() ^ Qt::ItemIsEditable);
	m_tableWidgetMaterial->setItem(2, 0, item3Mat);
	m_tableWidgetMaterial->setCellWidget(2, 1, m_materialIDSpinBox);


	QTableWidgetItem *item3Room = new QTableWidgetItem("Room Name", QTableWidgetItem::Type);
	m_tableWidgetRooms->setMinimumWidth(500);
	item3Room->setFlags(item3Room->flags() ^ Qt::ItemIsEditable);
	m_tableWidgetRooms->setItem(2, 0, item3Room);
	m_tableWidgetRooms->setCellWidget(2, 1, m_roomNameLine);


	QTableWidgetItem *item3APName = new QTableWidgetItem("Access Point Name", QTableWidgetItem::Type);
	m_tableWidgetAccessPoints->setMinimumWidth(500);
	item3APName->setFlags(item3APName->flags() ^ Qt::ItemIsEditable);
	m_tableWidgetAccessPoints->setItem(2, 0, item3APName);
	m_tableWidgetAccessPoints->setCellWidget(2, 1, m_accessPointName);



	QTableWidgetItem *item4ApHeight = new QTableWidgetItem("AP Height", QTableWidgetItem::Type);
	m_tableWidgetAccessPoints->setMinimumWidth(500);
	item4ApHeight->setFlags(item4ApHeight->flags() ^ Qt::ItemIsEditable);
	m_tableWidgetAccessPoints->setItem(3, 0, item4ApHeight);
	m_tableWidgetAccessPoints->setCellWidget(3, 1, m_accessPointHeightSpinBox);

	


	QTableWidgetItem *item2 = new QTableWidgetItem("Initial Latitude1", QTableWidgetItem::Type);
	item2->setFlags(item2->flags() ^ Qt::ItemIsEditable);
	m_tableWidgetGeojson->setItem(1, 0, item2);	
	m_tableWidgetGeojson->setCellWidget(1, 1, m_latitudeSpinBox1);
	
	

	QTableWidgetItem *item3 = new QTableWidgetItem("Initial Longtitude2", QTableWidgetItem::Type);
	item3->setFlags(item3->flags() ^ Qt::ItemIsEditable);
	m_tableWidgetGeojson->setItem(2, 0, item3);
	m_tableWidgetGeojson->setCellWidget(2, 1, m_longtitudeSpinBox2);
	
	

	QTableWidgetItem *item4 = new QTableWidgetItem("Initial Latitude2", QTableWidgetItem::Type);
	item4->setFlags(item4->flags() ^ Qt::ItemIsEditable);
	m_tableWidgetGeojson->setItem(3, 0, item4);
	m_tableWidgetGeojson->setCellWidget(3, 1, m_latitudeSpinBox2);




	QTableWidgetItem *item4Mat = new QTableWidgetItem("Material Name", QTableWidgetItem::Type);
	m_tableWidgetMaterial->setMinimumWidth(500);
	item4Mat->setFlags(item4Mat->flags() ^ Qt::ItemIsEditable);
	m_tableWidgetMaterial->setItem(3, 0, item4Mat);
	m_tableWidgetMaterial->setCellWidget(3, 1, m_materialNameComboBox);




	QTableWidgetItem *item4Room = new QTableWidgetItem("Building Name", QTableWidgetItem::Type);
	m_tableWidgetRooms->setMinimumWidth(500);
	item4Room->setFlags(item4Room->flags() ^ Qt::ItemIsEditable);
	m_tableWidgetRooms->setItem(3, 0, item4Room);
	m_tableWidgetRooms->setCellWidget(3, 1, m_buildingNameLine);


	QTableWidgetItem *item5Mat = new QTableWidgetItem("Material Tickness", QTableWidgetItem::Type);
	m_tableWidgetMaterial->setMinimumWidth(500);
	item5Mat->setFlags(item5Mat->flags() ^ Qt::ItemIsEditable);
	m_tableWidgetMaterial->setItem(4, 0, item5Mat);
	m_tableWidgetMaterial->setCellWidget(4, 1, m_materialTicknessSpinBox);


	QTableWidgetItem *item6Mat = new QTableWidgetItem("Wall Height", QTableWidgetItem::Type);
	m_tableWidgetMaterial->setMinimumWidth(500);
	item6Mat->setFlags(item6Mat->flags() ^ Qt::ItemIsEditable);
	m_tableWidgetMaterial->setItem(5, 0, item6Mat);
	m_tableWidgetMaterial->setCellWidget(5, 1, m_wallHeightSpinBox);





	m_wallDetectionAlgName = new QLabel;
	m_wallDetectionAlgName->setText("Wall Detection");


	m_WallRemoveLabelName = new QLabel;
	m_WallRemoveLabelName->setText("Wall Remove");

	m_zoomLabelName = new QLabel;
	m_zoomLabelName->setText("Zoom ");


	m_WallRemoveCheckbox = new QCheckBox;
	m_WallRemoveCheckbox->setChecked(false);
	
	//m_wallDetectionAlgName->set
	//m_wallDetectionAlgName->setText("Wall Detection");

	m_graphicsRectItem = new QGraphicsRectItem;

	m_graphicsTextItem = new QGraphicsTextItem;
	
	m_graphicsTextItem->setDefaultTextColor(QColor(0, 255, 0));


	m_elipseItemForAxisPoint = new QGraphicsEllipseItem;
	

	m_tableWidgetGeojson->verticalHeader()->setVisible(false);
	m_tableWidgetGeojson->horizontalHeader()->setVisible(false);

	m_tableWidgetMaterial->verticalHeader()->setVisible(false);
	m_tableWidgetMaterial->horizontalHeader()->setVisible(false);

	m_tableWidgetRooms->verticalHeader()->setVisible(false);
	m_tableWidgetRooms->horizontalHeader()->setVisible(false);

	m_tableWidgetAccessPoints->verticalHeader()->setVisible(false);
	m_tableWidgetAccessPoints->horizontalHeader()->setVisible(false);

	m_tableWidgetHeightMapData->verticalHeader()->setVisible(false);
	m_tableWidgetHeightMapData->horizontalHeader()->setVisible(false);



	m_tableWidgetForWallData->verticalHeader()->setVisible(false);
	m_tableWidgetForWallData->horizontalHeader()->setVisible(false);
	
	layoutForGeojsonWidget->addWidget(m_tableWidgetGeojson);
	layoutForGeojsonWidget->addWidget(btn1);


	layoutForWalllWidget->addWidget(m_tableWidgetMaterial);
	layoutForWalllWidget->addWidget(btn2);


	layoutForRoomsWidget->addWidget(m_tableWidgetRooms);
	layoutForRoomsWidget->addWidget(btn3);
	

	layoutForAccessPointsWidget->addWidget(m_tableWidgetAccessPoints);
	layoutForAccessPointsWidget->addWidget(btn4);

	layoutForHeightMapParameters->addWidget(m_tableWidgetHeightMapData);
	layoutForHeightMapParameters->addWidget(btn5);


	layoutForCurrentWallData->addWidget(m_tableWidgetForWallData);
	layoutForCurrentWallData->addWidget(btn6);





	m_geoJsonWidget->setLayout(layoutForGeojsonWidget);
	m_roomsWidget->setLayout(layoutForRoomsWidget);
	m_materialsWidget->setLayout(layoutForWalllWidget);
	m_accessPointsWidget->setLayout(layoutForAccessPointsWidget);
	m_heightMapParamWidget->setLayout(layoutForHeightMapParameters);
	m_wallDataWidget->setLayout(layoutForCurrentWallData);


	std::string imageSizeFileName = "imageSize.txt";
	std::ofstream fileSize;
	fileSize.open(imageSizeFileName);
	fileSize.close();






	m_selectSegmentLayout = new QHBoxLayout();
	m_selectSegmentLayout->addWidget(m_selectImageButton);
	m_selectSegmentLayout->addWidget(m_runSegmentationButton);
	m_selectSegmentLayout->addWidget(m_runHeightMapGenerationButton);
	m_selectSegmentLayout->addWidget(m_runComponentsDetectionButton);
	m_selectSegmentLayout->addWidget(m_runAccessPointDetectionButton);
	m_selectSegmentLayout->addWidget(m_runGeojsonGenerationButton);
	m_selectSegmentLayout->addWidget(m_selectLastSelectedWallButton);
	m_selectSegmentLayout->addWidget(m_selectLastSelectedWallLineButton);
	m_selectSegmentLayout->addWidget(m_runResetButton);


	m_wallRemoveLayout = new QHBoxLayout();
	m_wallRemoveLayout->addWidget(m_WallRemoveLabelName);
	m_wallRemoveLayout->addWidget(m_WallRemoveCheckbox);
	
	m_wallRemoveLayout->addWidget(m_zoomDownButton);
	m_wallRemoveLayout->addWidget(m_zoomUpButton);


	m_heightMapParametersLayout = new QVBoxLayout();
	m_heightMapParametersLayout->addWidget(m_selectComponentWidget);
	m_heightMapParametersLayout->addWidget(m_DbmShowingButton);
	m_heightMapParametersLayout->addWidget(m_SinrShowingButton);
	m_heightMapParametersLayout->addWidget(m_contourShowingButton);
	m_heightMapParametersLayout->addWidget(m_applyHeightMapData);


	m_automatedDetectionLayout = new QVBoxLayout();

	m_automatedDetectionLayout->addLayout(m_wallRemoveLayout);
	m_automatedDetectionLayout->addWidget(m_wallDetectionAlgName);
	m_automatedDetectionLayout->addWidget(m_automatedDetectionAlgCombobox);

	m_parametersHorizaontalLayout = new QHBoxLayout();
	m_parametersHorizaontalLayout->addLayout(m_heightMapParametersLayout);	
	m_parametersHorizaontalLayout->addLayout(m_automatedDetectionLayout);







	m_mainLayout= new QVBoxLayout();
	/*m_mainLayout->addWidget(m_selectComponentWidget);
	m_mainLayout->addWidget(m_DbmShowingButton);
	m_mainLayout->addWidget(m_SinrShowingButton);
	m_mainLayout->addWidget(m_contourShowingButton);
	m_mainLayout->addWidget(m_applyHeightMapData);*/
	m_mainLayout->addLayout(m_parametersHorizaontalLayout);
	m_mainLayout->addWidget(m_mainGraphicsView);
	m_mainLayout->addLayout(m_selectSegmentLayout);
/////	m_mainLayout->addWidget(m_selectImageButton);
/////	m_mainLayout->addWidget(m_runSegmentationButton);
////	m_mainLayout->addWidget(m_runHeightMapGenerationButton);

	//QWidget * w = new QWidget();
	m_mainWidget->setLayout(m_mainLayout);


	ui.setupUi(this);
	this->setCentralWidget(m_mainWidget);
	connect(m_selectImageButton, SIGNAL(clicked()), this, SLOT(setSelectedImagePath()));
	connect(m_runSegmentationButton, SIGNAL(clicked()), this, SLOT(runSegmentation()));
	connect(m_runHeightMapGenerationButton, SIGNAL(clicked()), this, SLOT(runHeightMapGeneration()));
	connect(m_mainGraphicsScene, SIGNAL(selectPointOnScene()), SLOT(getSelectedPoints()));
	connect(m_mainGraphicsScene, SIGNAL(finishSelectingPoints()), SLOT(drawPolygonFromSelectedPoints()));
	connect(m_mainGraphicsScene, SIGNAL(selectMovedPoint()), SLOT(drawHeightMapValue()));
	connect(m_mainGraphicsScene, SIGNAL(selectDrawingRect()), SLOT(drawSelectedRectangle()));
	connect(m_mainGraphicsScene, SIGNAL(drawCurrentRect()), SLOT(drawCurrentRectangle()));
	connect(m_mainGraphicsScene, SIGNAL(removeLastSelectedPoint()), SLOT(onRemoveLastSelectedPoint()));
    //connect(m_parametersWidget, SIGNAL(WidgetClosed()),  SLOT(coloringOfSelectedPolygonSlot()));
	connect(btn1, &QPushButton::clicked, m_geoJsonWidget, &QDialog::accept);
	connect(btn2, &QPushButton::clicked, m_materialsWidget, &QDialog::accept);
	connect(btn3, &QPushButton::clicked, m_roomsWidget, &QDialog::accept);
	connect(btn4, &QPushButton::clicked, m_accessPointsWidget, &QDialog::accept);
	connect(btn5, &QPushButton::clicked, m_heightMapParamWidget, &QDialog::accept);
	connect(btn6, &QPushButton::clicked, m_wallDataWidget, &QDialog::accept);
	connect(m_DbmShowingButton, SIGNAL(clicked()), this, SLOT(dbmShowingSlot()));
	connect(m_SinrShowingButton, SIGNAL(clicked()), this, SLOT(sinrShowingSlot()));
	connect(m_selectComponentWidget, SIGNAL(currentIndexChanged(const QString&)),this, SLOT(switchComponentType(const QString&)));
	connect(m_applyHeightMapData, SIGNAL(clicked()), this, SLOT(writeHeightMapPointsDataSlot()));
	connect(m_contourShowingButton, SIGNAL(clicked()), this, SLOT(drawHeightMapContourSlot()));
	connect(m_runResetButton, SIGNAL(clicked()), this, SLOT(resetSceneSlot()));
	connect(m_runComponentsDetectionButton, SIGNAL(clicked()), this, SLOT(detectComponentsSlot()));
	connect(m_runAccessPointDetectionButton, SIGNAL(clicked()), this, SLOT(detectAccessPoints()));
	connect(m_runGeojsonGenerationButton, SIGNAL(clicked()), this, SLOT(generateGeoJsonSlot()));
	connect(m_selectLastSelectedWallButton, SIGNAL(clicked()), this, SLOT(addLastSelectedWallSlot()));
	connect(m_selectLastSelectedWallLineButton, SIGNAL(clicked()), this, SLOT(addLastSelectedWallLineSlot()));
	//connect(m_zoomOptionSpinBox, SIGNAL(valueChanged(int)), this, SLOT(zommCurrentImageSlot(int)));
	connect(m_zoomDownButton, SIGNAL(clicked()), this, SLOT(zoomDownSlot()));
	connect(m_zoomUpButton, SIGNAL(clicked()), this, SLOT(zoomUpSlot()));
	//m_parametersWidget
}




 const wchar_t *  FloorPlanSegmentationGui::GetWC(const char *c)
{
	const size_t cSize = strlen(c) + 1;
	wchar_t* wc = new wchar_t[cSize];
	mbstowcs(wc, c, cSize);
	return wc;

}


 void  FloorPlanSegmentationGui::callPythonFunction(/*const std::vector<int>& imageSizes*/)
{
	PyObject *pName, *pModule, *pFunc;
	PyObject *pArgs, *pValue;
	int i;
	pArgs = NULL;
	std::cout << "Prepare for python call !!!!! \n";
	/*if (argc < 3) {
	fprintf(stderr, "Usage: call pythonfile funcname [args]\n");
	return 1;
	}*/

////	Py_Initialize();

////	pName = PyUnicode_FromString("MainRf_rayTracingCurrentState");
	
	/* Error checking of pName left out */
	//if (!m_isPythonModuleInitialized) {
		//m_pModule = new PyObject;
		
	////	m_pModule = PyImport_Import(pName);
	
//	}
	std::cout << "Prepare for python call111111111111111111111 !!!!! \n";
////	Py_DECREF(pName);
	//if (m_pModule == NULL) {
	//	std::cout << "Module is null \n";
	

		///Py_Initialize();
		Py_Initialize();
		//pName = PyUnicode_FromString("MainRf_rayTracingCurrentState");

	
		//if (!m_isPythonModuleInitialized) {
		//m_pModule = new PyObject;

	//	m_pModule = PyImport_Import(pName);
		m_pFunc = PyObject_GetAttrString(m_pModule, "finalFunctionHeightMap");

	//}
	if (m_pModule != NULL) {
		//if (!m_isPythonModuleInitialized) {
		    std::cout << "Before Pfunction \n";
		//	m_pFunc = PyObject_GetAttrString(m_pModule, "finalFunctionHeightMap");
			std::cout << "After PFunction \n";
		//	m_isPythonModuleInitialized = true;
	//	}
		/* pFunc is a new reference */

		if (m_pFunc && PyCallable_Check(m_pFunc)) {
			//pArgs = PyTuple_New(2);
			/*for (i = 0; i < imageSizes.size(); ++i) {
				//	pValue = PyInt_FromLong(atoi(argv[i + 3]));
				std::cout << "Inside for cycle \n";
				pValue = PyLong_FromLong(imageSizes[i]);

				if (!pValue) {
					Py_DECREF(pArgs);
					Py_DECREF(m_pModule);
					fprintf(stderr, "Cannot convert argument\n");
					return;
				
				PyTuple_SetItem(pArgs, i, pValue);
			}*/
			std::cout << "Python function calll final !!!!! \n";
			pValue = PyObject_CallObject(m_pFunc, pArgs);
			Py_DECREF(pArgs);
			if (pValue != NULL) {

				printf("Result of call: %ld\n", PyLong_AsLong(pValue));
				Py_DECREF(pValue);
			}
			else {
				Py_DECREF(m_pFunc);
				Py_DECREF(m_pModule);
				PyErr_Print();
				fprintf(stderr, "Call failed\n");
				return;
			}
		}
		else {
			if (PyErr_Occurred())
				PyErr_Print();
			//fprintf(stderr, "Cannot find function \"%s\"\n", argv[2]);
		}
		Py_XDECREF(m_pFunc);
		Py_DECREF(m_pModule);
	}
	else {
		PyErr_Print();
		//fprintf(stderr, "Failed to load \"%s\"\n", argv[1]);
		return;
	}
	Py_Finalize();
	return;

}


void FloorPlanSegmentationGui::mousePressEvent(QGraphicsSceneMouseEvent * e)
{


	std::cout << "PRESSSSSSSSSSSSSSSSSSSSS " << std::endl;
	double rad = 1;

	//std::cout << "XXXXXXXXXXXXXXXXXXXXX   " << e->pos().x()<<std::endl;
	//	QPointF pt = m_mainGraphicsView->mapFromParent(e->pos());
	//std::cout << "POint coors " << std::endl;
	//m_mainGraphicsScene->addEllipse(pt.x() - rad, pt.y() - rad, rad, rad,
	//QPen(), QBrush(Qt::SolidPattern));

}

void FloorPlanSegmentationGui::switchComponentType(const QString& compName)
{
	/*std::cout << "Value changed \n";
	if (compName.toStdString() != "HeightMap") {
		m_fs.release();
	}*/


	if (m_selectComponentWidget->currentText() != "HeightMap") {
		std::string imageSizeFileName = "imageSize.txt";
		std::ofstream fileSize;
		fileSize.open(imageSizeFileName);
		fileSize.close();
	}



	if (compName.toStdString() == "HeightMap") {
		std::cout << "Opened new file !!!!!!!!!!!! \n";
		std::string filename = "testHeightMapData.xml";
		cv::FileStorage fs(filename, cv::FileStorage::WRITE);
		fs.release();

		std::string filename2 = "testHeightMapDataThickness․xml";
		cv::FileStorage fs2(filename2, cv::FileStorage::WRITE);
		fs2.release();



		std::string filenameP = "testHeightMapDataParameters․xml";
		cv::FileStorage fsP(filenameP, cv::FileStorage::WRITE);
		fsP.release();



		
		std::string filename1 = "testHeightMapDataAutoGenerated.xml";
		cv::FileStorage fs1(filename1, cv::FileStorage::WRITE);
		fs1.release();



		QList<QGraphicsItem*> all = m_mainGraphicsScene->items();

		std::cout << "After getting items " << all.size() << " \n";
		//m_mainGraphicsScene->clear();
		//if (all.size() > 0) {
		for (int i = 0; i < all.size(); i++)
		{
			QGraphicsItem *gi = all[i];
			m_mainGraphicsScene->removeItem(gi);
			//delete gi;
			m_mainGraphicsScene->update();
		}

		m_pixmapItem =  new QGraphicsPixmapItem();
		m_mainGraphicsScene->addItem(m_pixmapItem);
		m_pixmapItem->setPixmap(QPixmap::fromImage(m_image));
		m_pixmapItem->setPos(0, 0);

		m_pixmapItem = NULL;
		delete m_pixmapItem;

		m_poly.clear();
		for (int i = 0; i < m_elipseItemsVec.size(); ++i) {
			m_mainGraphicsScene->removeItem(m_elipseItemsVec[i]);

		}
		for (int i = 0; i < m_elipseItemsVec.size(); ++i) {
			//m_mainGraphicsScene->removeItem(m_elipseItemsVec[i]);
			delete m_elipseItemsVec[i];
		}
		m_elipseItemsVec.clear();

		qDebug() << "Dialog closed imid";

		m_countOfHeightMapPoints = 0;
		m_pointsVecForHeightMap.clear();
		std::cout << "Selected heightmap mode \n";
		m_applyHeightMapData->setEnabled(true);
		m_runHeightMapGenerationButton->setEnabled(false);
		m_isSelectedAxisPoint = false;
	}
	/*else {
		m_pixmapItem = new QGraphicsPixmapItem();
		m_mainGraphicsScene->addItem(m_pixmapItem);
		
		m_pixmapItem->setPixmap(QPixmap::fromImage(m_image));
		m_pixmapItem->setPos(0, 0);

		m_pixmapItem = NULL;
		delete m_pixmapItem;
	}*/




	
}

void FloorPlanSegmentationGui::writeAutomateDetWallData()
{


	if (!m_WallRemoveCheckbox->isChecked()) {
		if (m_selectComponentWidget->currentText() == "HeightMap" &&  m_heightMapParamWidget->exec() == QDialog::Accepted) {
			std::cout << "Getting height map parameters from GUi\n";
			m_rayFreqForHeightMap = m_rayFreqSpinBox->value();
			m_countOfRaysForHeightMap = m_countOfRaysSpinBox->value();
			m_deviceAlignmentAngle = m_deviceAlignmentSpinBox->value();
			m_pixelPerMeterScaleParameterForHeightMap = m_pixelPerMeterScaleSpinBox->value();

		}
	}



	std::string filenameParam = "testHeightMapDataParameters.xml";
	cv::FileStorage fsParam(filenameParam, cv::FileStorage::APPEND);

	std::string vectorNameParam = "Parameters";
	fsParam << vectorNameParam << "{";
	std::string rayFreq = "RayFrequency";
	std::string raysCount = "RaysCount";
	std::string scaleOfPixelPerMeter = "ScalePixelPerMeter";
	std::string lossModelName = "LossModel";
	bool lossModelType = 0;
	if (m_modelForHeightMapComboBox->currentText().toStdString() == "Path Loss Model") {
		lossModelType = true;
	}
	else {
		lossModelType = false;

	}
	fsParam << rayFreq << m_rayFreqForHeightMap << raysCount << m_countOfRaysForHeightMap << scaleOfPixelPerMeter << m_pixelPerMeterScaleParameterForHeightMap<<lossModelName<<lossModelType;
	fsParam << "}";
	fsParam.release();


	std::cout << "HeightMap points count " << m_pointsVecForHeightMap.size() << std::endl;




	std::string filename = "testHeightMapData.xml";
	cv::FileStorage fs(filename, cv::FileStorage::APPEND);


	std::string filenameT = "testHeightMapDataThickness.xml";
	cv::FileStorage fsT(filenameT, cv::FileStorage::APPEND);


	std::string filenameP = "testHeightMapDataParameters.xml";
	cv::FileStorage fsP(filenameP, cv::FileStorage::APPEND);


	std::vector<std::vector<cv::Point>> detectedWallPoints = m_componentDetector.getDetectedWallPoints();
	materialDataStr tmpMaterialDataStr;
	std::pair<QPolygonF, materialDataStr> tmpMaterialDataPair;

	tmpMaterialDataStr.m_materialID = std::atoi(m_materialIDSpinBox->text().toStdString().c_str());
	tmpMaterialDataStr.m_materialName = m_materialNameComboBox->currentText().toStdString();
	tmpMaterialDataStr.m_materialTickness = std::atoi(m_materialTicknessSpinBox->text().toStdString().c_str());
	tmpMaterialDataStr.m_materialType = m_materialTypeComboBox->currentText().toStdString();
	tmpMaterialDataStr.m_currentWallHeight = m_wallHeightSpinBox->value();
	tmpMaterialDataPair.second = tmpMaterialDataStr;

	QPointF tmpPointFromWallFirst;
	QPointF tmpPointFromWallSecond;
	tmpPointFromWallFirst.setX(m_initialGeojsonPointCoord.first);
	tmpPointFromWallFirst.setY(m_initialGeojsonPointCoord.second);

	tmpPointFromWallSecond.setX(m_secondGeojsonPointCoord.first);
	tmpPointFromWallSecond.setY(m_secondGeojsonPointCoord.second);
	m_polyAutoDetected.clear();
	m_polyAutoDetected.push_back(tmpPointFromWallFirst);
	m_polyAutoDetected.push_back(tmpPointFromWallSecond);
	tmpMaterialDataPair.first = m_polyAutoDetected;
	m_multiLineWalls.push_back(tmpMaterialDataPair);
	m_polyAutoDetected.clear();





	for (int i = 0; i < detectedWallPoints.size(); ++i) {
		if (detectedWallPoints[i].size() < 10) {
			continue;
		}
		for (int g = 0; g < detectedWallPoints[i].size()-10; g+=10) {
			//Write each vector
			if (std::abs(detectedWallPoints[i][g].y - detectedWallPoints[i][g + 10].y) > 10 || std::abs(detectedWallPoints[i][g].x - detectedWallPoints[i][g + 10].x) > 10) {
				continue;
			}
			std::string vectorName = "vector" + std::to_string((long)(i+g));
			fs << vectorName << "{";
			fsT << vectorName << "{";

			std::string pointNameX0 = "x" + std::to_string(0);
			std::string pointNameY0 = "y" + std::to_string(0);
			std::string pointNameX1 = "x" + std::to_string(1);
			std::string pointNameY1 = "y" + std::to_string(1);
			fs << pointNameX0 << detectedWallPoints[i][g].x << pointNameY0 << detectedWallPoints[i][g].y;
			QPointF tmpPointFromWall;
			tmpPointFromWall.setX(detectedWallPoints[i][g].x);
			tmpPointFromWall.setY(detectedWallPoints[i][g].y);
			m_polyAutoDetected.push_back(tmpPointFromWall);
			std::string currentThickness = "thickness";
			std::string currentPermittivity = "permittivity";
			std::string currentlossTangen = "lossTangent";
			fsT << currentThickness << 10;
			fsT << currentPermittivity << 4;
			fsT << currentlossTangen << 0.01;
			//if (i == m_pointsVecForHeightMap.size() - 1 && m_countOfHeightMapPoints % 2 == 1) {
			//	fs << pointNameX1 << m_pointsVecForHeightMap[i].first.x << pointNameY1 << m_pointsVecForHeightMap[i].first.y;
			//}
			//else {
			fs << pointNameX1 << detectedWallPoints[i][g+10].x << pointNameY1 << detectedWallPoints[i][g+10].y;
			//}
			fsT << "}";
			fs << "}"; // close vector

		}

		

		tmpMaterialDataPair.first = m_polyAutoDetected;
		std::cout << tmpMaterialDataStr.m_materialID << "     " << tmpMaterialDataStr.m_materialName << "     " << tmpMaterialDataStr.m_materialTickness << "      " << tmpMaterialDataStr.m_materialType << std::endl;
		m_multiLineWalls.push_back(tmpMaterialDataPair);
		coloringOfSelectedWalls();
		m_polyAutoDetected.clear();







	}
	m_runGeojsonGenerationButton->setEnabled(true);
	fs.release();
	fsT.release();

	/*for (int i = 0; i < m_pointsVecForHeightMap.size(); ++i)
	{
		//Write each vector
		std::string vectorName = "vector" + std::to_string((long)i);
		fs << vectorName << "{";

		std::string pointNameX0 = "x" + std::to_string(0);
		std::string pointNameY0 = "y" + std::to_string(0);
		std::string pointNameX1 = "x" + std::to_string(1);
		std::string pointNameY1 = "y" + std::to_string(1);
		fs << pointNameX0 << m_pointsVecForHeightMap[i].first.x << pointNameY0 << m_pointsVecForHeightMap[i].first.y;
		if (i == m_pointsVecForHeightMap.size() - 1 && m_countOfHeightMapPoints % 2 == 1) {
			fs << pointNameX1 << m_pointsVecForHeightMap[i].first.x << pointNameY1 << m_pointsVecForHeightMap[i].first.y;
		}
		else {
			fs << pointNameX1 << m_pointsVecForHeightMap[i].second.x << pointNameY1 << m_pointsVecForHeightMap[i].second.y;
		}

	
		fs << "}"; // close vector
	}
	
	fs.release();*/

	if (m_isSelectedAxisPoint == true && m_pointsVecForHeightMap.size() > 0) {
		m_runHeightMapGenerationButton->setEnabled(true);
	}
	m_pointsVecForHeightMap.clear();
	m_countOfHeightMapPoints = 0;
}

void FloorPlanSegmentationGui::writeHeightMapPointsDataSlot()
{
	if (m_heightMapParamWidget->exec() == QDialog::Accepted){
		std::cout << "Getting height map parameters from GUi\n";
		m_rayFreqForHeightMap = m_rayFreqSpinBox->value();
		m_countOfRaysForHeightMap = m_countOfRaysSpinBox->value();
		m_deviceAlignmentAngle = m_deviceAlignmentSpinBox->value();
		m_pixelPerMeterScaleParameterForHeightMap = m_pixelPerMeterScaleSpinBox->value();
		
	}
	std::cout << "HeightMap points count " << m_pointsVecForHeightMap.size() << std::endl;

	std::string filename = "testHeightMapData.xml";
	cv::FileStorage fs(filename, cv::FileStorage::APPEND);



	std::string filenameParam = "testHeightMapDataParameters.xml";
	cv::FileStorage fsParam(filenameParam, cv::FileStorage::APPEND);

	std::string vectorNameParam = "Parameters";
	fsParam << vectorNameParam << "{";
	std::string rayFreq = "RayFrequency";
	std::string deviceAlignment = "DeviceAlignment";
	std::string raysCount = "RaysCount";
	std::string scaleOfPixelPerMeter = "ScalePixelPerMeter";
	std::string lossModelName = "LossModel";
	bool lossModelType = 0;
	if (m_modelForHeightMapComboBox->currentText().toStdString() == "Path Loss Model") {
		lossModelType = true;
	}
	else {
		lossModelType = false;

	}
	fsParam << rayFreq << m_rayFreqForHeightMap << raysCount << m_countOfRaysForHeightMap << scaleOfPixelPerMeter << m_pixelPerMeterScaleParameterForHeightMap << lossModelName << lossModelType<<deviceAlignment<<m_deviceAlignmentAngle;
	fsParam << "}";
	fsParam.release();


	/*fsParam << "RaysCount" << m_countOfRaysForHeightMap;*/



	std::string filenameT = "testHeightMapDataThickness.xml";
	cv::FileStorage fsT(filenameT, cv::FileStorage::APPEND);



	std::vector<std::vector<cv::Point>> myvector;
		for (int i = 0; i < 3; ++i) {
			std::vector<cv::Point> tmpVec;
			myvector.push_back(tmpVec);
		}
	
		cv::Point point11 = cv::Point(10, 20);
		cv::Point point12 = cv::Point(10, 50);
		myvector[0].push_back(point11);
		myvector[0].push_back(point12);
	
		cv::Point point21 = cv::Point(50, 50);
		cv::Point point22 = cv::Point(100, 50);
		myvector[1].push_back(point21);
		myvector[1].push_back(point22);
	
		cv::Point point31 = cv::Point(150, 150);
		cv::Point point32 = cv::Point(200, 200);
		myvector[2].push_back(point31);
		myvector[2].push_back(point32);
	
	
	
//		std::string filename = "testHeightMapData.xml";
	//	cv::FileStorage fs(filename, cv::FileStorage::WRITE);
		//fs << "data" << "{";
		for (int i = 0; i < m_pointsVecForHeightMap.size(); ++i)
		{
			//Write each vector
			std::string vectorName ="vector" + std::to_string((long)i) ;
			fs <<  vectorName<< "{";
			fsT << vectorName << "{";




	
			//fsParam << "RayFrequency" << m_rayFreqForHeightMap << "RaysCount" << m_countOfRaysForHeightMap;
			//fs << pointName << "{";
			//for (int j = 0; j < m_pointsVecForHeightMap[i].size(); ++j)
		//	{
				std::string pointNameX0 = "x" + std::to_string(0);
				std::string pointNameY0 = "y" + std::to_string(0);
				std::string pointNameX1 = "x" + std::to_string(1);
				std::string pointNameY1 = "y" + std::to_string(1);
				std::string currentThickness = "thickness" ;
				std::string currentPermittivity = "permittivity";
				std::string currentlossTangen = "lossTangent";
				fsT << currentThickness << 10;
				fsT << currentPermittivity << 4;
				fsT << currentlossTangen << 0.1;

			
				fs << pointNameX0 << m_pointsVecForHeightMap[i].first.x << pointNameY0 << m_pointsVecForHeightMap[i].first.y;
				
			
				if (i == m_pointsVecForHeightMap.size() - 1 && m_countOfHeightMapPoints % 2 == 1) {
					fs << pointNameX1 << m_pointsVecForHeightMap[i].first.x << pointNameY1 << m_pointsVecForHeightMap[i].first.y;
				}
				else {
					fs << pointNameX1 << m_pointsVecForHeightMap[i].second.x << pointNameY1 << m_pointsVecForHeightMap[i].second.y;
				}

				//fs << "}"; // close point
	//		}
			fs << "}"; // close vector
			fsT << "}";
			
		
		}
		//fs << "}"; // close data
		fs.release();
		fsT.release();


		if (m_isSelectedAxisPoint == true && m_pointsVecForHeightMap.size() > 0 ) {
			m_runHeightMapGenerationButton->setEnabled(true);
		}
		m_pointsVecForHeightMap.clear();
		m_countOfHeightMapPoints = 0;
		
	
}


void FloorPlanSegmentationGui::drawHeightMapContourSlot()
{

	std::cout << "contour drawing slot !!!!!!!!!!!!!  \n";

	cv::Mat heightmapImage;
	heightmapImage = m_heightMapImage.clone();
	//QImage image;
	if (m_contourShowingButton->isChecked()) {
		heightmapImage = heightmapImage + m_contourImage.clone();
	} 
	QImage image(heightmapImage.data, heightmapImage.cols, heightmapImage.rows, QImage::Format_RGB888);




	//	QImage image(fileName);
	//image = image.scaled(image.width()/1.3,image.height()/1.3);
	/////	m_image = image;
	QList<QGraphicsItem*> all = m_mainGraphicsScene->items();

	std::cout << "After getting items " << all.size() << " \n";
	//m_mainGraphicsScene->clear();
	//if (all.size() > 0) {
	for (int i = 0; i < all.size(); i++)
	{
		QGraphicsItem *gi = all[i];
		m_mainGraphicsScene->removeItem(gi);
		//delete gi;
		m_mainGraphicsScene->update();
	}
	m_pixmapItem = new QGraphicsPixmapItem();
	m_mainGraphicsScene->addItem(m_pixmapItem);
	m_pixmapItem->setPixmap(QPixmap::fromImage(image));
	m_pixmapItem->setPos(0, 0);




}




void FloorPlanSegmentationGui::resetSceneSlot()
{

	
	//QImage image(heightmapImage.data, heightmapImage.cols, heightmapImage.rows, QImage::Format_RGB888);




	//	QImage image(fileName);
	//image = image.scaled(image.width()/1.3,image.height()/1.3);
	/////	m_image = image;


	std::string imageSizeFileName = "imageSize.txt";
	std::ofstream fileSize;
	fileSize.open(imageSizeFileName);
	fileSize.close();

	std::string filename = "testHeightMapData.xml";
	cv::FileStorage fs(filename, cv::FileStorage::WRITE);
	fs.release();



	std::string filenameP = "testHeightMapDataParameters.xml";
	cv::FileStorage fsP(filenameP, cv::FileStorage::WRITE);
	fsP.release();

	std::string filenameT = "testHeightMapDataThickness.xml";
	cv::FileStorage fsT(filenameT, cv::FileStorage::WRITE);
	fsT.release();

	std::string filenameI = "testHeightMapDataImproved.xml";
	cv::FileStorage fsI(filenameI, cv::FileStorage::WRITE);
	fsI.release();




	QList<QGraphicsItem*> all = m_mainGraphicsScene->items();

	std::cout << "After getting items " << all.size() << " \n";
	//m_mainGraphicsScene->clear();
	//if (all.size() > 0) {
	for (int i = 0; i < all.size(); i++)
	{
		QGraphicsItem *gi = all[i];
		m_mainGraphicsScene->removeItem(gi);
		//delete gi;
		m_mainGraphicsScene->update();
	}
	m_pixmapItem = new QGraphicsPixmapItem();
	m_mainGraphicsScene->addItem(m_pixmapItem);
	m_pixmapItem->setPixmap(QPixmap::fromImage(m_image));
	m_pixmapItem->setPos(0, 0);


	m_poly.clear();
	m_multiLineWalls.clear();
	m_multiPoints.clear();
	m_multiPolygonRooms.clear();
	m_multiAccessPoints.clear();
}



void FloorPlanSegmentationGui::removeWallComponentsByUser()
{
	QRect selectedRect = m_mainGraphicsScene->returnSelectedRectangle();
	std::vector<std::vector<cv::Point>> detectedWallsVec = m_componentDetector.getDetectedWallPoints();
	std::vector<std::vector<cv::Point>> detectedWallsVecRes;// (detectedWallsVec.size());
	cv::Rect currentSelectedRect;
	currentSelectedRect.x = m_mainGraphicsScene->returnSelectedRectangle().x();
	currentSelectedRect.y = m_mainGraphicsScene->returnSelectedRectangle().y();
	currentSelectedRect.width = m_mainGraphicsScene->returnSelectedRectangle().width();
	currentSelectedRect.height = m_mainGraphicsScene->returnSelectedRectangle().height();

	int currentInsertionIndex = -1;
	for (auto i = 0; i < detectedWallsVec.size(); i++) {
		++currentInsertionIndex;
		std::vector<cv::Point> tmpContourVector;
		for (auto j = 0; j < detectedWallsVec[i].size(); ++j) {
			if (!(detectedWallsVec[i][j].x >= currentSelectedRect.x && detectedWallsVec[i][j].y >= currentSelectedRect.y &&
				detectedWallsVec[i][j].x <= currentSelectedRect.x + currentSelectedRect.width  && detectedWallsVec[i][j].y <= currentSelectedRect.y + currentSelectedRect.height)) {
				tmpContourVector.push_back(detectedWallsVec[i][j]);
			}
			else {
				detectedWallsVecRes.push_back(tmpContourVector);
				tmpContourVector.clear();
			}
		}
		detectedWallsVecRes.push_back(tmpContourVector);


		
	}


	resetSceneSlot();
	m_componentDetector.setUpdatedDetectedWalls(detectedWallsVecRes);

	
	QBrush brush;
	brush.setColor(Qt::green);


	writeAutomateDetWallData();


	brush.setStyle(Qt::SolidPattern);
	QPen pen(Qt::green);
	pen.setBrush(brush);
	pen.setWidth(1);


	for (int i = 0; i < detectedWallsVecRes.size(); ++i) {
		for (int j = 0; j < detectedWallsVecRes[i].size(); ++j) {
			QGraphicsEllipseItem* elipseItem = new QGraphicsEllipseItem;
			elipseItem->setPen(pen);
			elipseItem->setBrush(brush);
			elipseItem->setRect(detectedWallsVecRes[i][j].x, detectedWallsVecRes[i][j].y, 1, 1);
			m_mainGraphicsScene->addItem(elipseItem);


			elipseItem = NULL;
			delete elipseItem;
		}

		//	m_elipseItemsVec.push_back(elipseItem);

	}





	//std::vector<std::vector<cv::Point>> detectedWallsVec
		//m_componentDetector.se

}

void FloorPlanSegmentationGui::detectComponentsSlot()
{


	m_componentDetector.findInnerAndOuterWallPoints(m_automatedDetectionAlgCombobox->currentText().toStdString());

	//Detection based on  thresshold points 
	std::vector<cv::Point> detectedPointsVec = m_componentDetector.getDetectedPoints();
	std::vector<std::vector<cv::Point>> detectedWallsVec = m_componentDetector.getDetectedWallPoints();
	QBrush brush;
	brush.setColor(Qt::green);


	writeAutomateDetWallData();


	brush.setStyle(Qt::SolidPattern);
	QPen pen(Qt::green);
	pen.setBrush(brush);
	pen.setWidth(1);

	for (int i = 0; i < detectedWallsVec.size(); ++i) {
		for (int j = 0; j < detectedWallsVec[i].size(); ++j) {
			QGraphicsEllipseItem* elipseItem = new QGraphicsEllipseItem;
			elipseItem->setPen(pen);
			elipseItem->setBrush(brush);
			elipseItem->setRect(detectedWallsVec[i][j].x, detectedWallsVec[i][j].y, 1, 1);
			m_mainGraphicsScene->addItem(elipseItem);

		
			elipseItem = NULL;
			delete elipseItem;
		}

		//	m_elipseItemsVec.push_back(elipseItem);

	}





	/*cv::Mat resultCompImage = m_componentDetector.getResultImage();
	std::vector<std::vector<cv::Point>> autoDetectedWallPointsVec = m_componentDetector.getDetectedWallPoints();
	for (int f = 0; f < autoDetectedWallPointsVec.size(); ++f) {
		for (int r = 0; r < autoDetectedWallPointsVec[f].size(); ++r) {
			cv::circle(resultCompImage, autoDetectedWallPointsVec[f][r], 1, cv::Scalar(0, 255, 0), -1);
		}
	}


	QImage imgResComp = QImage((uchar*)resultCompImage.data, resultCompImage.cols, resultCompImage.rows, resultCompImage.step, QImage::Format_RGB888);
	m_image = imgResComp;

	m_pixmapItem->setPixmap(QPixmap::fromImage(m_image));
	m_pixmapItem->setPos(0, 0);*/
	//m_mainGraphicsScene->update();






	std::string filename = "testHeightMapDataAutoGenerated1.xml";
	cv::FileStorage fs(filename, cv::FileStorage::WRITE);



	for (int i = 0; i < detectedPointsVec.size(); ++i)
	{
		//Write each vector
		std::string vectorName = "vector" + std::to_string((long)i);
		fs << vectorName << "{";
		//fs << pointName << "{";
		//for (int j = 0; j < m_pointsVecForHeightMap[i].size(); ++j)
		//	{
		std::string pointNameX0 = "x" + std::to_string(0);
		std::string pointNameY0 = "y" + std::to_string(0);
		//std::string pointNameX1 = "x" + std::to_string(1);
		//std::string pointNameY1 = "y" + std::to_string(1);
		fs << pointNameX0 << detectedPointsVec[i].x << pointNameY0 << detectedPointsVec[i].y;
		

		//fs << "}"; // close point
		//		}
		fs << "}"; // close vector
	}
	//fs << "}"; // close data
	fs.release();






}




void FloorPlanSegmentationGui::detectAccessPoints()
{



	std::cout << "Acess Point detection \n";

	if (m_selectComponentWidget->currentText()!= "AccessPoint") {
		return;
	}

	cv::Mat src;
	std::cout << "Channels count " << m_cvImage.channels() << std::endl;
	if (m_cvImage.channels() == 4) {
		cv::cvtColor(m_cvImage, src, CV_BGRA2BGR);// cv::imread("E:/upworkProjs/FloorPlanAnalyzing/Venue_Images/TuckerStadium/APLayout.PNG", 1);
	}
	else {
		src = m_cvImage.clone();
	}
	if (src.channels() == 1) {
		return;
	}
	

	if (m_cvImage.cols == 0 || m_cvImage.rows == 0) {
		return;
	}
	cv::RNG rng(123456789);

	std::cout << "Access points count  !!!!  " << m_multiPoints.size() << std::endl;
	if (m_multiPoints.size() == 0) {
		return;
	}
	
	for (int i = 0; i < m_multiPoints.size(); ++i) {
		cv::Point lastSelectedPoint;
		lastSelectedPoint.x = m_multiPoints[i].x;
		lastSelectedPoint.y = m_multiPoints[i].y;
		cv::Mat resultImg = cv::Mat(src.rows, src.cols, CV_8UC1, cv::Scalar::all(255));
		std::vector<std::vector<cv::Point> > contours;
		std::vector<cv::Vec4i> hierarchy;


	


		//	Mat src = imread("E:/upworkProjs/FloorPlanAnalyzing/Venue_Images/USTA/ArthurAshe/ArthurAsheScoreboard.PNG", 1);


		cv::Vec3b inputPixelValue = src.at<cv::Vec3b>(lastSelectedPoint.y, lastSelectedPoint.x); // cv::Vec3b(0, 255, 255);


		for (int i = 0; i < resultImg.rows; ++i) {
			for (int j = 0; j < resultImg.cols; ++j) {
				if (std::abs(src.at<cv::Vec3b>(i, j)[0] - inputPixelValue[0]) < 10 &&
					std::abs(src.at<cv::Vec3b>(i, j)[1] - inputPixelValue[1]) < 10 &&
					std::abs(src.at<cv::Vec3b>(i, j)[2] - inputPixelValue[2]) < 10) {
					resultImg.at<uchar>(i, j) = 0;
				}
			}
		}


		//cv::waitKey(0);
		cv::Mat cannyImg;
		//cv::blur(resultImg, resultImg, cv::Size(3, 3));
		cv::Canny(resultImg, cannyImg, 50, 100, 3);
		cv::findContours(cannyImg, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, cv::Point(0, 0));
		cv::Mat drawing = cv::Mat::zeros(cannyImg.size(), CV_8UC3);
		cv::Scalar color = cv::Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
		for (int i = 0; i < contours.size(); i++)
		{
		
			cv::Rect tmpRect = cv::boundingRect(contours[i]);
			cv::rectangle(src, tmpRect, color, -1);
			//drawContours(drawing, contours, i, color, 2, 8, hierarchy, 0, cv::Point());
		}

		/*cv::imshow("ResImg", resultImg);
		cv::imshow("Drawing", drawing);
		cv::imshow("SRC", src);
		cv::waitKey(0);*/


		/*cv::cvtColor(src, src, CV_BGR2RGB);
		QImage imgIn = QImage((uchar*)src.data, src.cols, src.rows, src.step, QImage::Format_RGB888);
		m_pixmapItem->setPixmap(QPixmap::fromImage(imgIn));
		m_pixmapItem->setPos(0, 0);*/
	//	cv::circle(src, cv::Point(lastSelectedPoint.x, lastSelectedPoint.y), 5, cv::Scalar(255, 0, 0), 3);

	}


	QList<QGraphicsItem*> all = m_mainGraphicsScene->items();

	std::cout << "After getting items " << all.size() << " \n";
	//m_mainGraphicsScene->clear();
	//if (all.size() > 0) {
	for (int i = 0; i < all.size(); i++)
	{
		QGraphicsItem *gi = all[i];
		m_mainGraphicsScene->removeItem(gi);
		//delete gi;
		m_mainGraphicsScene->update();
	}




	cv::cvtColor(src, src, CV_BGR2RGB);
	QImage image((uchar*)src.data, src.cols, src.rows, src.step,QImage::Format_RGB888);
	
	m_pixmapItem = new QGraphicsPixmapItem();
	m_mainGraphicsScene->addItem(m_pixmapItem);
	m_pixmapItem->setPixmap(QPixmap::fromImage(image));
	m_pixmapItem->setPos(0, 0);


}



void FloorPlanSegmentationGui::generateGeoJsonSlot()
{
	std::cout << "Called geojson generation \n";
	if (m_selectComponentWidget->currentText() == "Wall" ) {
		std::cout << "Called geojson generation for automated walls  \n";
		generateGeojsonFileForWalls();
	} else if (m_selectComponentWidget->currentText() == "Room") {
		generateGeojsonFileForRooms();
	}
	else if (m_selectComponentWidget->currentText() == "AccessPoint") {
		std::cout << "Befiore function call \n";
		generateGeojsonFileForAccessPoints();
	}


	std::cout << "After function call \n";
}

void FloorPlanSegmentationGui::addLastSelectedWallSlot()
{



	QBrush brush;
	brush.setColor(Qt::red);

	brush.setStyle(Qt::SolidPattern);
	QPen pen(Qt::green);
	pen.setBrush(brush);
	pen.setWidth(1);

	unsigned int currentLastElementIndexInLastPolygon = m_multiLineWalls[m_multiLineWalls.size() - 1].first.size() - 1;
	std::cout << "Last wall reconstructing part \n";
	std::cout << "Last point " << m_multiLineWalls[m_multiLineWalls.size() - 1].first.at(currentLastElementIndexInLastPolygon).x() << "   " << m_multiLineWalls[m_multiLineWalls.size() - 1].first.at(currentLastElementIndexInLastPolygon).y() << std::endl;
	//m_multiLineWalls[0].first.at(m_multiLineWalls.size() - 1).

	QGraphicsEllipseItem* elipseItem = new QGraphicsEllipseItem;
	elipseItem->setPen(pen);
	elipseItem->setBrush(brush);

	
	std::cout << "CURRENT ELEMENT INDEX " << currentLastElementIndexInLastPolygon << std::endl;
	std::cout << "SIze of multiwalls " << m_multiLineWalls.size() << std::endl;
	elipseItem->setRect(m_multiLineWalls[m_multiLineWalls.size()-1].first.at(currentLastElementIndexInLastPolygon).x()-5, m_multiLineWalls[m_multiLineWalls.size()-1].first.at(currentLastElementIndexInLastPolygon).y()-5, 10, 10);
	
	m_mainGraphicsScene->addItem(elipseItem);
	m_mainGraphicsScene->update();
	m_poly << QPointF(m_multiLineWalls[m_multiLineWalls.size() - 1].first.at(currentLastElementIndexInLastPolygon).x(), m_multiLineWalls[m_multiLineWalls.size() - 1].first.at(currentLastElementIndexInLastPolygon).y());
	
	elipseItem = NULL;
	delete elipseItem;



    //m_elipseItemsVec.push_back()
	//m_mainGraphicsScene->addItem(m_elipseItemsVec.at(m_elipseItemsVec.size()-1));
	//m_elipseItemsVec.push_back(elipseItem);
}



void FloorPlanSegmentationGui::addLastSelectedWallLineSlot()
{



	QBrush brush;
	brush.setColor(Qt::red);

	brush.setStyle(Qt::SolidPattern);
	QPen pen(Qt::green);
	pen.setBrush(brush);
	pen.setWidth(1);


	unsigned int currentLastElementIndexInLastPolygon1;
	unsigned int currentLastElementIndexInLastPolygon2;
	if (m_multiLineWalls[m_multiLineWalls.size() - 1].first.size() >= 2) {
		currentLastElementIndexInLastPolygon1  = m_multiLineWalls[m_multiLineWalls.size() - 1].first.size() - 2;
		currentLastElementIndexInLastPolygon2  = m_multiLineWalls[m_multiLineWalls.size() - 1].first.size() - 1;
	}
	else {
		return;
	}
	std::cout << "Last wall reconstructing part \n";
	//std::cout << "Last point " << m_multiLineWalls[m_multiLineWalls.size() - 1].first.at(currentLastElementIndexInLastPolygon).x() << "   " << m_multiLineWalls[m_multiLineWalls.size() - 1].first.at(currentLastElementIndexInLastPolygon).y() << std::endl;
	//m_multiLineWalls[0].first.at(m_multiLineWalls.size() - 1).

	QGraphicsEllipseItem* elipseItem1 = new QGraphicsEllipseItem;
	elipseItem1->setPen(pen);
	elipseItem1->setBrush(brush);



	QGraphicsEllipseItem* elipseItem2 = new QGraphicsEllipseItem;
	elipseItem2->setPen(pen);
	elipseItem2->setBrush(brush);


	//std::cout << "CURRENT ELEMENT INDEX " << currentLastElementIndexInLastPolygon1 << std::endl;
	//std::cout << "SIze of multiwalls " << m_multiLineWalls.size() << std::endl;
	elipseItem1->setRect(m_multiLineWalls[m_multiLineWalls.size() - 1].first.at(currentLastElementIndexInLastPolygon1).x() - 5, m_multiLineWalls[m_multiLineWalls.size() - 1].first.at(currentLastElementIndexInLastPolygon1).y() - 5, 10, 10);
	elipseItem2->setRect(m_multiLineWalls[m_multiLineWalls.size() - 1].first.at(currentLastElementIndexInLastPolygon2).x() - 5, m_multiLineWalls[m_multiLineWalls.size() - 1].first.at(currentLastElementIndexInLastPolygon2).y() - 5, 10, 10);

	std::cout << "ADDED LAST SELECTED LINE \n";

	m_mainGraphicsScene->addItem(elipseItem1);
	m_mainGraphicsScene->addItem(elipseItem2);
	m_mainGraphicsScene->update();
	m_poly << QPointF(m_multiLineWalls[m_multiLineWalls.size() - 1].first.at(currentLastElementIndexInLastPolygon1).x(), m_multiLineWalls[m_multiLineWalls.size() - 1].first.at(currentLastElementIndexInLastPolygon1).y());
	m_poly << QPointF(m_multiLineWalls[m_multiLineWalls.size() - 1].first.at(currentLastElementIndexInLastPolygon2).x(), m_multiLineWalls[m_multiLineWalls.size() - 1].first.at(currentLastElementIndexInLastPolygon2).y());


	drawPolygonFromSelectedPoints();

	//m_multiLineWalls.first = m_poly;

	elipseItem1 = NULL;
	delete elipseItem1;
	elipseItem2 = NULL;
	delete elipseItem2;


}

void FloorPlanSegmentationGui::zoomDownSlot()
{
	if (m_previousZoomValue - 10 > 10) {
		if (m_previousZoomValue > 100) {
			m_previousZoomValue = 100;
		}
		m_previousZoomValue = m_previousZoomValue - 10;
	}
	zommCurrentImageSlot();

}


void FloorPlanSegmentationGui::zoomUpSlot()
{
	if (m_previousZoomValue +  10 <= 300) {
		if (m_previousZoomValue < 100) {
			m_previousZoomValue = 100;
		}
		m_previousZoomValue = m_previousZoomValue + 10;
	}
	zommCurrentImageSlot();

}


void FloorPlanSegmentationGui::zommCurrentImageSlot()
{
	


	QList<QGraphicsItem*> all = m_mainGraphicsScene->items();

	std::cout << "ZOOOOOOOOM" << all.size() << " \n";
	//m_mainGraphicsScene->clear();
	//if (all.size() > 0) {
	for (int i = 0; i < all.size(); i++)
	{
		QGraphicsItem *gi = all[i];
		m_mainGraphicsScene->removeItem(gi);
		//delete gi;
		m_mainGraphicsScene->update();
	}
	m_pixmapItem = new QGraphicsPixmapItem();
	m_mainGraphicsScene->addItem(m_pixmapItem);
	m_pixmapItem->setPixmap(QPixmap::fromImage(m_image));
	m_pixmapItem->setPos(0, 0);


	m_poly.clear();
	for (int i = 0; i < m_elipseItemsVec.size(); ++i) {
		m_mainGraphicsScene->removeItem(m_elipseItemsVec[i]);

	}
	for (int i = 0; i < m_elipseItemsVec.size(); ++i) {
		//m_mainGraphicsScene->removeItem(m_elipseItemsVec[i]);
		delete m_elipseItemsVec[i];
	}
	m_elipseItemsVec.clear();




	m_mainGraphicsScene->setSceneRect(0, 0, m_image.width(), m_image.height());
	//	m_mainGraphicsScene->clear();
	QImage temp = m_image.copy();



	std::cout << "     Initial depth state           " << temp.depth() << std::endl;;


	if (temp.depth() != 0) {
		if (temp.depth() == 8) {
			cv::Mat res(temp.height(), temp.width(), CV_8UC1, (uchar*)temp.bits(), temp.bytesPerLine());
			//cvtColor(res, res, CV_BGRA2BGR);
			m_cvImage = res.clone();
		}
		else if (temp.depth() == 32) {
			cv::Mat res(temp.height(), temp.width(), CV_8UC4, (uchar*)temp.bits(), temp.bytesPerLine());
			//cvtColor(res, res, CV_BGRA2BGR);
			m_cvImage = res.clone();

		}
		else if (temp.depth() == 24) {
			cv::Mat res(temp.height(), temp.width(), CV_8UC3, (uchar*)temp.bits(), temp.bytesPerLine());
			//cvtColor(res, res, CV_BGRA2BGR);
			m_cvImage = res.clone();

		}

	}
	
	m_pixmapItem->setPixmap(QPixmap::fromImage(m_image));
	m_pixmapItem->setPos(0, 0);


	all = m_mainGraphicsScene->items();

	std::cout << "After getting items " << all.size() << " \n";
	//m_mainGraphicsScene->clear();
	//if (all.size() > 0) {
	for (int i = 0; i < all.size(); i++)
	{
		QGraphicsItem *gi = all[i];
		m_mainGraphicsScene->removeItem(gi);
		delete gi;
		m_mainGraphicsScene->update();
	}
	//}

	QGraphicsPixmapItem*   m_pixmapItem = new QGraphicsPixmapItem;//  new QGraphicsPixmapItem(/*QPixmap::fromImage(image)*/);

	m_pixmapItem->setPixmap(QPixmap::fromImage(m_image));
	m_pixmapItem->setPos(0, 0);
	m_mainGraphicsScene->addItem(m_pixmapItem);

	float scaleByX = (float)(m_previousZoomValue) / 100.0;
	float scaleByY = (float)(m_previousZoomValue) / 100.0;
	 m_mainGraphicsView->scale(scaleByX, scaleByY);
	

	std::string filename1 = "testHeightMapDataAutoGenerated.xml";
	cv::FileStorage fs1(filename1, cv::FileStorage::WRITE);
	fs1.release();


	std::ofstream geojsonFile;
	geojsonFile.open("example.geojson");
	geojsonFile.close();
	//	delete pixmapItemTmp;


	m_multiLineWalls.clear();
	m_multiPoints.clear();
	m_multiPolygonRooms.clear();









}

void FloorPlanSegmentationGui::setSelectedImagePath() {


	std::string imageSizeFileName = "imageSize.txt";
	std::ofstream fileSize;
	fileSize.open(imageSizeFileName);
	fileSize.close();

	std::string filename = "testHeightMapData.xml";
	cv::FileStorage fs(filename, cv::FileStorage::WRITE);
	fs.release();

	std::string filenameP = "testHeightMapDataParameters.xml";
	cv::FileStorage fsP(filenameP, cv::FileStorage::WRITE);
	fsP.release();

	std::string filenameT = "testHeightMapDataThickness.xml";
	cv::FileStorage fsT(filenameT, cv::FileStorage::WRITE);
	fsT.release();


	m_isSelectedAxisPoint = false;
	m_runHeightMapGenerationButton->setEnabled(false);

	QString fileName = QFileDialog::getOpenFileName(this,
		tr("Open Image"), "/home/jana", tr("Image Files (*.png *.jpg *.bmp)"));
	std::cout << "CLICKED !!!!" << std::endl;
	//QString filename = "E:/upworkProjs/FloorPlanAnalyzing/Venue_Images/TuckerStadium/1.png";
	QImage image(fileName);
	//image = image.scaled(image.width()/1.3,image.height()/1.3);
	m_image = image;



	QList<QGraphicsItem*> all = m_mainGraphicsScene->items();

	std::cout << "After getting items " << all.size() << " \n";
	//m_mainGraphicsScene->clear();
	//if (all.size() > 0) {
	for (int i = 0; i < all.size(); i++)
	{
		QGraphicsItem *gi = all[i];
		m_mainGraphicsScene->removeItem(gi);
		//delete gi;
		m_mainGraphicsScene->update();
	}
	m_pixmapItem = new QGraphicsPixmapItem();
	m_mainGraphicsScene->addItem(m_pixmapItem);
	m_pixmapItem->setPixmap(QPixmap::fromImage(m_image));
	m_pixmapItem->setPos(0, 0);

	
	m_poly.clear();
	for (int i = 0; i < m_elipseItemsVec.size(); ++i) {
		m_mainGraphicsScene->removeItem(m_elipseItemsVec[i]);

	}
	for (int i = 0; i < m_elipseItemsVec.size(); ++i) {
		//m_mainGraphicsScene->removeItem(m_elipseItemsVec[i]);
		delete m_elipseItemsVec[i];
	}
	m_elipseItemsVec.clear();






	//fileSize.open(imageSizeFileName);
	//fileSize << m_image.width() << " " << m_image.height() << " " << 10 << " " << 10;
	//fileSize.close();



	m_mainGraphicsScene->setSceneRect(0,0,image.width(), image.height());
//	m_mainGraphicsScene->clear();
	QImage temp = m_image.copy();


	
	std::cout << "     Initial depth state           " << temp.depth() << std::endl;;
	
	
	if (temp.depth() != 0) {
		if (temp.depth() == 8) {
			cv::Mat res(temp.height(), temp.width(), CV_8UC1, (uchar*)temp.bits(), temp.bytesPerLine());
			//cvtColor(res, res, CV_BGRA2BGR);
			m_cvImage = res.clone();
		}
		else if (temp.depth() == 32) {
			cv::Mat res(temp.height(), temp.width(), CV_8UC4, (uchar*)temp.bits(), temp.bytesPerLine());
			//cvtColor(res, res, CV_BGRA2BGR);
			m_cvImage = res.clone();

		}
		else if (temp.depth() == 24) {
			cv::Mat res(temp.height(), temp.width(), CV_8UC3, (uchar*)temp.bits(), temp.bytesPerLine());
			//cvtColor(res, res, CV_BGRA2BGR);
			m_cvImage = res.clone();

		}

	}
	/*else {
		return;
	}
	cv::imshow("CurrentImage", m_cvImage);
	cv::waitKey(0);*/

	//cv::Mat tmpImageContDet = QImageToCvMat(temp, true);
//	cvtColor(tmpImageContDet, tmpImageContDet, cv::COLOR_RGB2BGR);

	m_componentDetector = componentsDetector();
	m_componentDetector.setInputImage(fileName.toStdString());


//	m_componentDetector.findInnerAndOuterWallPoints("innerAggressive");
	//m_image = m_componentDetector.getResultImage();
//	m_componentDetector.visualizeDetections();


/*	cv::Mat resultCompImage = m_componentDetector.getResultImage();
	std::vector<std::vector<cv::Point>> autoDetectedWallPointsVec = m_componentDetector.getDetectedWallPoints();
	for (int f = 0; f < autoDetectedWallPointsVec.size(); ++f) {
		for (int r = 0; r < autoDetectedWallPointsVec[f].size(); ++r) {
			cv::circle(resultCompImage, autoDetectedWallPointsVec[f][r], 1, cv::Scalar(0, 255, 0), -1);
		}
	}


	QImage imgResComp = QImage((uchar*)resultCompImage.data, resultCompImage.cols, resultCompImage.rows, resultCompImage.step, QImage::Format_RGB888);
	m_image = imgResComp;
*/
	m_pixmapItem->setPixmap(QPixmap::fromImage(m_image));
	m_pixmapItem->setPos(0, 0);


	 all = m_mainGraphicsScene->items();
	
	std::cout << "After getting items " << all.size() << " \n";
	//m_mainGraphicsScene->clear();
	//if (all.size() > 0) {
		for (int i = 0; i < all.size(); i++)
		{
			QGraphicsItem *gi = all[i];
			m_mainGraphicsScene->removeItem(gi);
			delete gi;
			m_mainGraphicsScene->update();
		}
	//}
		
		QGraphicsPixmapItem*   m_pixmapItem =  new QGraphicsPixmapItem;//  new QGraphicsPixmapItem(/*QPixmap::fromImage(image)*/);
	
		m_pixmapItem->setPixmap(QPixmap::fromImage(m_image));
		m_pixmapItem->setPos(0, 0);
		m_mainGraphicsScene->addItem(m_pixmapItem);

		//m_mainGraphicsView->scale(4, 4);

		std::string filename1 = "testHeightMapDataAutoGenerated.xml";
		cv::FileStorage fs1(filename1, cv::FileStorage::WRITE);
		fs1.release();


		std::ofstream geojsonFile;
		geojsonFile.open("example.geojson");
		geojsonFile.close();
	//	delete pixmapItemTmp;

		
		m_multiLineWalls.clear();
		m_multiPoints.clear();
		m_multiPolygonRooms.clear();

	
		
}


void  FloorPlanSegmentationGui::runSegmentation() {

	int maximumContSize = 0;
	int indexOfBiggestCont = -1;
	cv::Mat canny_output;
	std::vector<std::vector<cv::Point> > contours;
	std::vector<std::vector<cv::Point> > filteredContours;
	std::vector<cv::Vec4i> hierarchy;
	

//	cv::imshow("InitImg", m_cvImage);
	//cv::waitKey(0);

	cv::Mat imgfordraw =  m_cvImage.clone();
	cv::Mat initialMat = m_cvImage.clone();
	std::cout << "Before crash " << std::endl;
	if (initialMat.channels() == 3) {
		cv::cvtColor(initialMat, initialMat, CV_BGR2GRAY);
	}
	
	std::cout << "After crash !!" << std::endl;

	

	cv::erode(initialMat, initialMat, cv::Mat());
		

	
	cv::Mat cannyImg;
	cv::Canny(initialMat, cannyImg, 150, 170);

	cv::findContours(cannyImg, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, cv::Point(0, 0));
	//std::cout << "contours sizwe " << contours.size() << std::endl;
	
	
	cv::Mat drawing = cv::Mat::zeros(initialMat.size(), CV_8UC3);
	
	for (int i = 0; i < contours.size(); ++i) {
			cv::Scalar color = cv::Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
			if (contours[i].size() > 10) {
				cv::drawContours(drawing, contours, i, color, 2, 8, hierarchy, 0, cv::Point());
			}
		}
	
	
	
		for (int i = 0; i< contours.size(); i++)       
		{
			//drawing = imgfordraw.clone(); 
			if (contours[i].size() > maximumContSize) {
				maximumContSize = contours[i].size();
				indexOfBiggestCont = i;
			}
			cv::Scalar color = cv::Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
			//if (contours[i][0] == contours[i][contours[i].size() - 1]) {
				//drawcontours(drawing, contours, i, color, 2, 8, hierarchy, 0, cv::point());
			//} 
		//	cv::waitkey(0);
		}



		;

	
		cv::Rect bigestrect = cv::boundingRect(contours[indexOfBiggestCont]);
		for (int j = 0; j < contours.size(); ++j) {
			cv::Rect tmprect = cv::boundingRect(contours[j]);
			if (    bigestrect.area() / tmprect.area() >= 1.  && bigestrect.area() / tmprect.area() < 100) {
				filteredContours.push_back(contours[j]);
				//cv::scalar color = cv::scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
				//drawcontours(drawing, contours, j, color, 2, 8, hierarchy, 0, cv::point());
			
			}
	
		}

		

	//	std::cout << "filtered contours size " << filteredContours.size() << std::endl;
		cv::Mat contMat = cv::Mat(imgfordraw.rows, imgfordraw.cols, CV_8UC3, cv::Scalar::all(0));


		

		for (int i = 0; i < filteredContours.size(); ++i) {
			cv::Scalar color = cv::Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
			drawContours(imgfordraw, filteredContours, i, color, 2, 8, hierarchy, 0, cv::Point());
			drawContours(contMat, filteredContours, i, color, 2, 8, hierarchy, 0, cv::Point());
		//	cv::pointpolygontest(filteredcontours[i],)
		//	cv::fillpoly(contmat, contours, cv::scalar(255, 255, 255));
		//	ispointinsidecontour(filteredcontours[i], contmat);
		//	std::cout << "current contour initiasl " << std::endl;
		
		}
	

		cv::imshow("drawinginit", contMat);
		cv::waitKey(0);

		for (int g = 0; g < filteredContours.size(); ++g) {
	
			//ispointinsidecontour(filteredcontours[g], contmat);
			//continue;
		//	std::cout << "current contour" << std::endl;
			cv::Rect tmprect = cv::boundingRect(filteredContours[g]);
			cv::Scalar color = cv::Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
		//	cv::scalar color = cv::scalar(0, 255, 0);
			for (int i = 0; i < imgfordraw.rows; ++i) {
				for (int j = 0; j < imgfordraw.cols; ++j) {
					//imgfordraw.at<cv::vec3b>(i, j) = cv::vec3b(255, 0, 0);
					
					if (  cv::pointPolygonTest(filteredContours[g],cv::Point2f(j,i),false)  /*tmprect.contains(cv::point2i(j,i))*//*cv::pointpolygontest(filteredcontours[g],cv::point2f(j,i),false) == 1 || cv::pointpolygontest(filteredcontours[g], cv::point2f(j, i), false) == 0*/) {
						contMat.at<cv::Vec3b>(i, j)[0] = color[0] ;
						contMat.at<cv::Vec3b>(i, j)[1] = color[1];
						contMat.at<cv::Vec3b>(i, j)[2] = color[2];
	
					}
					/*else if (cv::pointpolygontest(filteredcontours[g], cv::point2f(j, i), true) > -5) {
						contmat.at<cv::vec3b>(i, j)[0] = color[0];
						contmat.at<cv::vec3b>(i, j)[1] = color[1];
						contmat.at<cv::vec3b>(i, j)[2] = color[2];
					}*/
					
				//	cv::imshow("imgfordraw", imgfordraw);
				//	cv::waitkey(10);
					
				}
			}
			
		
		}
		//cv::imshow("drawinginit", contMat);
		//cv::waitKey(0);
		return;

	//	cv::namedWindow("contmatfinal");
		//cv::moveWindow("contmatfinal", 100, 100);
		//cv::imshow("contmatfinal", contMat);
		//cv::imwrite("e:/upworkprojs/floorplananalyzing/goodworkingexamples/2dfloorplansimpleres8.jpg",contmat);
		//cv::imshow("imgfordraw", imgfordraw);
		
		//cv::waitKey(0);
	//	drawcontours(drawing, contours, indexofbiggestcont, cv::scalar(0,255,0), 2, 8, hierarchy, 0, cv::point());
	
		for (int i = 0; i< contours.size(); i++)
		{
			if (contours[i].size() > maximumContSize) {
				maximumContSize = contours[i].size();
				indexOfBiggestCont = i;
			}
			if (i != maximumContSize) {
				cv::Scalar color = cv::Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
				cv::drawContours(drawing, contours, i, color, 2, 8, hierarchy, 0, cv::Point());
			}
		}


		QImage imgIn = QImage((uchar*)contMat.data, contMat.cols, contMat.rows, contMat.step, QImage::Format_RGB888);
		m_pixmapItem->setPixmap(QPixmap::fromImage(imgIn));
		m_pixmapItem->setPos(0, 0);
		

		
		
	//	cv::imshow("initimg", initialMat);		
		//cv::waitKey(0); 
	;
}


void FloorPlanSegmentationGui::runHeightMapGeneration()
{

	int retCode = system("HeightMapGeneration.exe ");
	if (retCode == 0) {
		return ;
	}
	cv::namedWindow("HeightMap1");
	cv::Mat heightmapImage = cv::imread("resultImageFull.png");
	
	QString fileName = "resultImageFull.png";
	

	QString fileName1 = "maskImgHeight.png";
	//QImage image1(fileName1);
	

	cv::Mat maskImg = cv::imread(fileName1.toStdString());
	cv::Mat grayImg;
	cv::cvtColor(maskImg, grayImg, CV_BGR2GRAY);



	cv::medianBlur(grayImg, grayImg, 15);

	unsigned int minPointX = grayImg.cols - 1;
	unsigned int maxPointX = 0;
	unsigned int minPointY = grayImg.rows - 1;
	unsigned int maxPointY = 0;
	for (int i = 0; i < grayImg.rows; ++i) {
		for (int j = 0; j < grayImg.cols; ++j) {
			if (grayImg.at<uchar>(i, j) != 0 && i < minPointY) {
				minPointY = i;
			}
			if (grayImg.at<uchar>(i, j) != 0 && j < minPointX) {
				minPointX = j;
			}
			if (grayImg.at<uchar>(i, j) != 0 && i > maxPointY) {
				maxPointY = i;
			}
			if (grayImg.at<uchar>(i, j) != 0 && j > maxPointX) {
				maxPointX = j;
			}
		}
	}
	cv::Rect rectBound;
	rectBound.x = minPointX;
	rectBound.y = minPointY;
	rectBound.width = maxPointX - minPointX;
	rectBound.height = maxPointY - minPointY;





	cv::cvtColor(grayImg, grayImg, CV_GRAY2BGR);
	cv::rectangle(grayImg, rectBound, cv::Scalar(0, 255, 0), 2);
	cv::imshow("grayImg", grayImg);
	cv::waitKey(10);



	cv::Mat resContourImage;
	findOuterContour(maskImg, resContourImage);

	cv::cvtColor(resContourImage, resContourImage, CV_BGR2RGB);
	QImage imageContour(resContourImage.data, resContourImage.cols, resContourImage.rows, QImage::Format_RGB888);

	

	cv::cvtColor(heightmapImage, heightmapImage, CV_BGR2RGB);
	m_heightMapImage = heightmapImage.clone();
	m_contourImage = resContourImage.clone();


//	if (m_contourShowingButton->isChecked()) {
		//heightmapImage = heightmapImage + resContourImage;
		cv::rectangle(heightmapImage, rectBound, cv::Scalar(0, 255, 0), 2);
	//}
	float realHeight = rectBound.height * 0.5;
	float realWidth = rectBound.width * 0.5;
	cv::putText(heightmapImage, std::to_string(realHeight), cv::Point(rectBound.x - 100, rectBound.y + 100),CV_FONT_HERSHEY_COMPLEX, 1,cv::Scalar(255, 0, 0), 2);
	cv::putText(heightmapImage, std::to_string(realWidth), cv::Point(rectBound.x + 100, rectBound.y - 100), CV_FONT_HERSHEY_COMPLEX, 1, cv::Scalar(255, 0, 0), 2);
	cv::Mat heightmapImageSave;
	cv::cvtColor(heightmapImage, heightmapImageSave, CV_BGR2RGB);
	cv::imwrite("HeightMapImageWithCoverage.png", heightmapImageSave);
	
	QImage image(heightmapImage.data, heightmapImage.cols, heightmapImage.rows, QImage::Format_RGB888);
	//Artashes Last change
	
   QImage imageTr(heightmapImage.data, heightmapImage.cols, heightmapImage.rows, QImage::Format_RGBA8888);
   QImage imageTr1 = QImage(heightmapImage.cols, heightmapImage.rows, QImage::Format_RGBA8888);

 


   for (int i = 0; i < imageTr1.height(); ++i) {
	   for (int j = 0; j < imageTr1.width(); ++j) {
		  // QRgb apixel = image.pixel(j, i);
		   //imageTr.setPixel(j, i,
			  // qRgba(image.pixel(j,i

		   imageTr1.setPixel(j, i,
			   qRgba(heightmapImage.at<cv::Vec3b>(i,j)[0],
				   heightmapImage.at<cv::Vec3b>(i, j)[1],
				   heightmapImage.at<cv::Vec3b>(i, j)[2],
				   230));
				//   qRgba valueTmp1 = QRgba(apixel.red(), apixel.green(), apixel.blue(), 200);
		   
		  // p2.setPixel(i, j, value);
	   }
	}

   m_image = imageTr1.copy();
    
//	QImage image(fileName);
	//image = image.scaled(image.width()/1.3,image.height()/1.3);
/////	m_image = image;
	QList<QGraphicsItem*> all = m_mainGraphicsScene->items();

	std::cout << "After getting items " << all.size() << " \n";
	//m_mainGraphicsScene->clear();
	//if (all.size() > 0) {
	for (int i = 0; i < all.size(); i++)
	{
		QGraphicsItem *gi = all[i];
		m_mainGraphicsScene->removeItem(gi);
		//delete gi;
		m_mainGraphicsScene->update();
	}



	m_pixmapItem = new QGraphicsPixmapItem();
	m_mainGraphicsScene->addItem(m_pixmapItem);
	m_pixmapItem->setPixmap(QPixmap::fromImage(m_image));
	m_pixmapItem->setPos(0, 0);

	m_pixmapItem = NULL;
	delete m_pixmapItem;

	m_pixmapItem = new QGraphicsPixmapItem();
	m_mainGraphicsScene->addItem(m_pixmapItem);
	m_pixmapItem->setPixmap(QPixmap::fromImage(imageTr1));
//	m_mainGraphicsScene->addItem(m_pixmapItem);
	m_pixmapItem->setPos(0, 0);
	
	m_pixmapItem = NULL;
	delete m_pixmapItem;

	cv::Mat resHeightMapImage;
	cv::Mat resSinrMapImage;
	parseHeightMapTxtFile(resHeightMapImage, resSinrMapImage);



/*	QList<QGraphicsItem*> all = m_mainGraphicsScene->items();

	std::cout << "After getting items " << all.size() << " \n";


	QImage image("testfileRes.png");
	//image = image.scaled(image.width()/1.3,image.height()/1.3);
	
	m_mainGraphicsScene->setSceneRect(0, 0, image.width(), image.height());
	m_pixmapItem = new QGraphicsPixmapItem();
	m_mainGraphicsScene->addItem(m_pixmapItem);
	m_pixmapItem->setPixmap(QPixmap::fromImage(image));
	m_pixmapItem->setPos(0, 0);

*/













	/*std::cout << "Called heihjt map generation \n";
	std::vector<int> imageSizeVec;
	imageSizeVec.push_back(m_image.width());
	imageSizeVec.push_back(m_image.height());*/
//	callPythonFunction(/*imageSizeVec*/);
		//PyObject *pName, *pModule, *pFunc;
		//PyObject *pArgs, *pValue;
		//int i;
	
	
		///*if (argc < 3) {
		//	fprintf(stderr, "Usage: call pythonfile funcname [args]\n");
		//	return 1;
		//}*/
	
		//Py_Initialize();
		//
		//pName = PyUnicode_FromString( "MainRf_rayTracingCurrentState");
		//
		///* Error checking of pName left out */
	
		//pModule = PyImport_Import(pName);
		//Py_DECREF(pName);
	
		//if (pModule != NULL) {
		//	pFunc = PyObject_GetAttrString(pModule, "finalFunctionHeightMap");
		//	/* pFunc is a new reference */
	
		//	if (pFunc && PyCallable_Check(pFunc)) {
		//		//pArgs = PyTuple_New(argc - 3);
		//		//for (i = 0; i < argc - 3; ++i) {
		//		////	pValue = PyInt_FromLong(atoi(argv[i + 3]));
		//		//	pValue =   PyLong_FromLong(atol(argv[i + 3]));
		//		//	
		//		//	if (!pValue) {
		//		//		Py_DECREF(pArgs);
		//		//		Py_DECREF(pModule);
		//		//		fprintf(stderr, "Cannot convert argument\n");
		//		//		return 1;
		//		//	}
		//		//	/* pValue reference stolen here: */
		//		//	PyTuple_SetItem(pArgs, i, pValue);
		//		//}
		//		std::cout << "Before calling function \n";
		//		//printf(pFunc.c);
		//		pValue = PyObject_CallObject(pFunc, pArgs);
		//		std::cout << "After calling functio n  \n";
		//		Py_DECREF(pArgs);
		//		if (pValue != NULL) {
		//			
		//			printf("Result of call: %ld\n", PyLong_AsLong(pValue));
		//			Py_DECREF(pValue);
		//		}
		//		else {
		//			Py_DECREF(pFunc);
		//			Py_DECREF(pModule);
		//			PyErr_Print();
		//			fprintf(stderr, "Call failed\n");
		//			return ;
		//		}
		//	}
		//	else {
		//		if (PyErr_Occurred())
		//			PyErr_Print();
		//		//fprintf(stderr, "Cannot find function \"%s\"\n", argv[2]);
		//	}
		//	Py_XDECREF(pFunc);
		//	Py_DECREF(pModule);
		//}
		//else {
		//	PyErr_Print();
		//	//fprintf(stderr, "Failed to load \"%s\"\n", argv[1]);
		//	return ;
		//}
		//Py_Finalize();	
}
 


void FloorPlanSegmentationGui::getSelectedPoints()
{

	QGraphicsLineItem* tmpLineitem = new QGraphicsLineItem;
	QGraphicsEllipseItem* elipseItem = new QGraphicsEllipseItem;
	std::cout << "GET SELECTED POINTS  " << std::endl;
	QPoint selectedPoint = m_mainGraphicsScene->transferPickedPointsPosition();
	std::cout << "Select points " << selectedPoint.x() << "   " << selectedPoint.y() << std::endl;


	QBrush brush;
	brush.setColor(Qt::red);
	brush.setStyle(Qt::SolidPattern);

	QPen pen(Qt::green);


	QPainter qPainter(&m_image);
	qPainter.setBrush(brush);
	qPainter.setPen(Qt::red);
	//qPainter.drawRect(selectedPoint.x(), selectedPoint.y(), 150, 150);
	//qPainter.drawEllipse(selectedPoint, 20, 20);


	//m_pixmapItem->setPixmap(QPixmap::fromImage(m_image));
	//m_pixmapItem->setPos(0, 0);


	QImage temp = m_image.copy();

//	if ( temp.hasAlphaChannel()){
//	cv::Mat res(temp.height(), temp.width(), CV_8UC3, (uchar*)temp.bits(), temp.bytesPerLine());


	//cv::circle(res, cv::Point(selectedPoint.x(), selectedPoint.y()), 20, cv::Scalar(0, 255, 0), 5);
	//cvtColor(res, res, CV_BGRA2BGR); // make convert colort to BGR ! 
									 //cv::imshow("Initimg", res);
									 //cv::waitKey(0);


	cv::Point tmpSelectedPoint = cv::Point(selectedPoint.x(), selectedPoint.y());




	if (  m_selectComponentWidget->currentText() == "HeightMap" &&  m_countOfHeightMapPoints % 2 == 0) {
		std::pair<cv::Point, cv::Point> tmpHeightSelPoint;
		tmpHeightSelPoint.first = tmpSelectedPoint;
		m_pointsVecForHeightMap.push_back(tmpHeightSelPoint);
		++m_countOfHeightMapPoints;
		std::cout << "Added one time " << m_countOfHeightMapPoints << std::endl;
	 
		
	}
	else if (m_selectComponentWidget->currentText() == "HeightMap" &&  m_countOfHeightMapPoints % 2 != 0)  {







		++m_countOfHeightMapPoints;
		std::cout << "Added second point " << m_countOfHeightMapPoints << std::endl;
		m_pointsVecForHeightMap[m_pointsVecForHeightMap.size() - 1].second = tmpSelectedPoint;

		QBrush brush;
		brush.setColor(Qt::green);

		brush.setStyle(Qt::SolidPattern);
		QPen pen(Qt::green);
		pen.setBrush(brush);
		pen.setWidth(5);
		
		//QLineF tmpLine;

	/////	QGraphicsLineItem* tmpLineitem = new QGraphicsLineItem;
		QLineF tmpLine;
		tmpLine.setLine(m_pointsVecForHeightMap[m_pointsVecForHeightMap.size() - 1].first.x, m_pointsVecForHeightMap[m_pointsVecForHeightMap.size() - 1].first.y, 
				m_pointsVecForHeightMap[m_pointsVecForHeightMap.size() - 1].second.x, m_pointsVecForHeightMap[m_pointsVecForHeightMap.size() - 1].second.y);
		tmpLineitem->setLine(tmpLine);
		tmpLineitem->setPen(pen);
		m_mainGraphicsScene->addItem(tmpLineitem);



		if (m_wallDataWidget->exec() == QDialog::Accepted) {
			std::cout << "Getting height map parameters from GUi\n";
			m_rayFreqForHeightMap = m_rayFreqSpinBox->value();
			m_countOfRaysForHeightMap = m_countOfRaysSpinBox->value();
			m_pixelPerMeterScaleParameterForHeightMap = m_pixelPerMeterScaleSpinBox->value();

		}





	
	}
	
	//m_mainGraphicsScene->clear();
	//m_mainGraphicsScene->addEllipse(tmpSelectedPoint.x, tmpSelectedPoint.y, 10, 10, pen, brush);
	
//	elipseItem->setPos(tmpSelectedPoint.x, tmpSelectedPoint.y);
	elipseItem->setPen(pen);
	elipseItem->setBrush(brush);
	if (m_selectComponentWidget->currentText() == "AccessPoint") {
		QBrush brush1;
		brush1.setColor(Qt::green);
		brush1.setStyle(Qt::SolidPattern);
		elipseItem->setBrush(brush1);
		elipseItem->setRect(tmpSelectedPoint.x-10, tmpSelectedPoint.y-10, 20, 20);
	}
	else {
		elipseItem->setRect(tmpSelectedPoint.x-5, tmpSelectedPoint.y-5, 10, 10);
	}
    m_mainGraphicsScene->addItem(elipseItem);
	m_elipseItemsVec.push_back(elipseItem);
	//	m_mainGraphicsScene->addEllipse(100, 100, 10, 10, pen, brush);
//if (m_poly.size() == 0 && m_indexOfPolygonPoint > 0) {
		m_poly << QPointF(tmpSelectedPoint.x, tmpSelectedPoint.y);
	//}
   /*if (m_selectComponentWidget->currentText() == "AccessPoint") {
			detectAccessPoints();
	}*/
      
	++m_indexOfPolygonPoint;

	
	//	detectAxisPoints(res, tmpSelectedPoint);

	elipseItem = NULL;
	delete elipseItem;

	tmpLineitem = NULL;
	delete tmpLineitem;


}

void FloorPlanSegmentationGui::drawPolygonFromSelectedPoints()
{
   
	QBrush brush;
	brush.setColor(Qt::red);
	brush.setStyle(Qt::SolidPattern);

	QPen pen(Qt::green);

//	m_mainGraphicsScene->addPolygon(m_poly, pen, brush);
	//setScene(graphics_scene_);
	//m_poly.clear();
//	m_tableWidget->show();
	//coloringOfSelectedPolygonSlot();

//	QPushButton* button = m_parametersWidget->findChild<QPushButton*>("Apply");
//	qDebug() << "COMPBOXOBOX TEST  " << m_roomTypeComboBoBox->currentText();
	int compRes  = QString::compare("Room", m_selectComponentWidget->currentText(), Qt::CaseInsensitive);
	int compResHeightMap = QString::compare("HeightMap", m_selectComponentWidget->currentText(), Qt::CaseInsensitive);
	std::cout << "Call double click function !!!!!!!!!  from drawPolygon BEFORE  !!!!! \n";
	if (   m_selectComponentWidget->currentText() == "Geojson"  && m_geoJsonWidget->exec() == QDialog::Accepted)
	{
		
		std::cout << "Call double click function !!!!!!!!!  from drawPolygon !!!!! \n";
		/*if (m_selectComponentWidget->currentText() == "AccessPoint") {
			detectAccessPoints();
		}*/
	
	//	if (m_selectComponentWidget->currentText() == "Geojson") {
			//m_rotationAngle = std::atof(m_rotationAngleSpinBox->text().toStdString().c_str());
			m_scaleValueX = std::atof(m_scaleValueSpinBoxX->text().toStdString().c_str());
			m_scaleValueY = std::atof(m_scaleValueSpinBoxY->text().toStdString().c_str());
			std::cout << "Selected wall points count WALLLLLLL " << m_poly.size() << std::endl;



			m_initialGeojsonPointCoord.first = m_poly[m_poly.size() - 2].x();
			m_initialGeojsonPointCoord.second = m_poly[m_poly.size() - 2].y();

			m_secondGeojsonPointCoord.first = m_poly[m_poly.size() - 1].x();
			m_secondGeojsonPointCoord.second = m_poly[m_poly.size() - 1].y();


			std::stringstream out;

			out << std::fixed << std::setprecision(10) << std::stof(m_longtitudeSpinBox1->text().toStdString());

			m_longtitudeValue1 = std::stof(out.str());
			std::cout << "Longtitgude 1 " << std::setprecision(10) << m_longtitudeValue1 << std::endl;

			std::stringstream out1;
			out1 << std::fixed << std::setprecision(10) << std::stof(m_latitudeSpinBox1->text().toStdString());

			m_latitudeValue1 = std::stof(out1.str());

			std::cout << "Latitude 1 " << std::setprecision(10) << m_latitudeValue1 << std::endl;

			std::stringstream out2;

			out2 << std::fixed << std::setprecision(10) << std::stof(m_longtitudeSpinBox2->text().toStdString());

			m_longtitudeValue2 = std::stof(out2.str());



			std::cout << "Longtitgude 2 " << std::setprecision(10) << m_longtitudeValue2 << std::endl;


			std::stringstream out3;
			out3 << std::fixed << std::setprecision(10) << std::stof(m_latitudeSpinBox2->text().toStdString());

			m_latitudeValue2 = std::stof(out3.str());

			std::cout << "Latitude 2 " << std::setprecision(10) << m_latitudeValue2 << std::endl;



			float rotationAngle;
			float distanceBwetweenPoints;
			findRotationAngleAndDistance(m_latitudeValue1, m_longtitudeValue1, m_latitudeValue2, m_longtitudeValue2, rotationAngle, distanceBwetweenPoints);
			m_realDistanceBetweenSelectedPoints = distanceBwetweenPoints;
			m_rotationAngle =  rotationAngle;

		//	findRotationAngleAndDistance()
			rotateCurrentPoint();
			rotateCurrentImage();
			m_runGeojsonGenerationButton->setEnabled(true);
		//}
		/*if (!compRes ) {
			std::cout << "Selected rooom !!!!!!!!!!!!!" << std::endl;
		
			coloringOfSelectedPolygonSlot();
		} 
		else if (m_selectComponentWidget->currentText() == "Wall"){
			std::cout << "COunt of wall points " << m_poly.size() << std::endl;

			materialDataStr tmpMaterialDataStr;
		//	tmpPolyMatData = std::pair<m_poly, tmpMaterialData>;
			std::pair<QPolygonF, materialDataStr> tmpMaterialDataPair;
			tmpMaterialDataPair.first = m_poly;
			tmpMaterialDataStr.m_materialID = std::atoi(m_materialIDSpinBox->text().toStdString().c_str());
			tmpMaterialDataStr.m_materialName = m_materialNameComboBox->currentText().toStdString();
			tmpMaterialDataStr.m_materialTickness = std::atoi(m_materialTicknessSpinBox->text().toStdString().c_str());
			tmpMaterialDataStr.m_materialType = m_materialTypeComboBox->currentText().toStdString();
			tmpMaterialDataPair.second = tmpMaterialDataStr;
			//tmpMaterialDataStr.m_materialTickness = m_mate
			
			m_multiLineWalls.push_back(tmpMaterialDataPair);
			coloringOfSelectedWalls();
		//	generateGeojsonFileLast();
			//rotateCurrentImage();
		}
		else if (m_selectComponentWidget->currentText() == "Room") {
			m_multiPolygonRooms.push_back(m_poly);

		}
		else if (m_selectComponentWidget->currentText() == "AccessPoint") {
			for (int i = 0; i < m_poly.size(); ++i) {
				cv::Point currentPoint;
				currentPoint.x = m_poly[i].x();
				currentPoint.y = m_poly[i].y();
				m_multiPoints.push_back(currentPoint);
			}
			//detectAccessPoints();
		}*/
		qDebug() << "Apply button pressed!!";



		/*std::stringstream out;
		
		out << std::fixed << std::setprecision(10) << std::stof(m_longtitudeSpinBox1->text().toStdString());

		m_longtitudeValue1 = std::stof(out.str());
		
		std::stringstream out1;
		out1 << std::fixed << std::setprecision(10) << std::stof(m_latitudeSpinBox1->text().toStdString());

		m_latitudeValue1 = std::stof(out1.str());
		


		std::stringstream out2;

		out2 << std::fixed << std::setprecision(10) << std::stof(m_longtitudeSpinBox2->text().toStdString());

		m_longtitudeValue2 = std::stof(out2.str());

		std::stringstream out3;
		out3 << std::fixed << std::setprecision(10) << std::stof(m_latitudeSpinBox2->text().toStdString());

		m_latitudeValue2 = std::stof(out3.str());*/



		std::cout << "After parsing \n";


		std::cout << "LOTITUDE VALUE1 !!!!!!!!!   " << m_longtitudeValue1<< std::endl;
		std::cout << "LATITUDE VALUE1 !!!    " << m_latitudeValue1 << std::endl;

		std::cout << "LOTITUDE VALUE2 !!!!!!!!!   " << m_longtitudeValue2 << std::endl;
		std::cout << "LATITUDE VALUE2 !!!    " << m_latitudeValue2 << std::endl;


		m_poly.clear();

		for (int j = 0; j < m_elipseItemsVec.size(); ++j) {
			m_elipseItemsVecMain.push_back(QPointF(m_elipseItemsVec[j]->x(), m_elipseItemsVec[j]->y()));

		}

		for (int i = 0; i < m_elipseItemsVec.size(); ++i) {
			m_mainGraphicsScene->removeItem(m_elipseItemsVec[i]);
			

		}
		for (int i = 0; i < m_elipseItemsVec.size(); ++i) {
			//m_mainGraphicsScene->removeItem(m_elipseItemsVec[i]);
			delete m_elipseItemsVec[i];
		}
		m_elipseItemsVec.clear();



	}
    else if (m_selectComponentWidget->currentText() == "Wall" &&  m_materialsWidget->exec() == QDialog::Accepted) {

		materialDataStr tmpMaterialDataStr;
		std::pair<QPolygonF, materialDataStr> tmpMaterialDataPair;

		tmpMaterialDataStr.m_materialID = std::atoi(m_materialIDSpinBox->text().toStdString().c_str());
		tmpMaterialDataStr.m_materialName = m_materialNameComboBox->currentText().toStdString();
		tmpMaterialDataStr.m_materialTickness = std::atoi(m_materialTicknessSpinBox->text().toStdString().c_str());
		tmpMaterialDataStr.m_materialType = m_materialTypeComboBox->currentText().toStdString();
		tmpMaterialDataStr.m_currentWallHeight = m_wallHeightSpinBox->value();
		tmpMaterialDataPair.second = tmpMaterialDataStr;

		tmpMaterialDataPair.first = m_poly;
		std::cout << tmpMaterialDataStr.m_materialID << "     " << tmpMaterialDataStr.m_materialName << "     " << tmpMaterialDataStr.m_materialTickness << "      " << tmpMaterialDataStr.m_materialType << std::endl;
		m_multiLineWalls.push_back(tmpMaterialDataPair);
		
		coloringOfSelectedWalls();
		m_poly.clear();

		for (int j = 0; j < m_elipseItemsVec.size(); ++j) {
			m_elipseItemsVecMain.push_back(QPointF(m_elipseItemsVec[j]->x(), m_elipseItemsVec[j]->y()));

		}

		for (int i = 0; i < m_elipseItemsVec.size(); ++i) {
			m_mainGraphicsScene->removeItem(m_elipseItemsVec[i]);


		}
		for (int i = 0; i < m_elipseItemsVec.size(); ++i) {
			//m_mainGraphicsScene->removeItem(m_elipseItemsVec[i]);
			delete m_elipseItemsVec[i];
		}
		m_elipseItemsVec.clear();
	}
	else if (m_selectComponentWidget->currentText() == "Room" &&  m_roomsWidget->exec() == QDialog::Accepted) {

		roomDataStr tmpMaterialDataStr;
		std::pair<QPolygonF, roomDataStr> tmpMaterialDataPair;

		tmpMaterialDataStr.m_buildingName = (m_buildingNameLine->text().toStdString().c_str());
		tmpMaterialDataStr.m_floorId = std::stoi(m_floorIDSpinbox->text().toStdString().c_str());
		tmpMaterialDataStr.m_roomName = m_roomNameLine->text().toStdString();
		tmpMaterialDataPair.second = tmpMaterialDataStr;

		tmpMaterialDataPair.first = m_poly;
	//	std::cout << tmpMaterialDataStr.m_materialID << "     " << tmpMaterialDataStr.m_materialName << "     " << tmpMaterialDataStr.m_materialTickness << "      " << tmpMaterialDataStr.m_materialType << std::endl;
		m_multiPolygonRooms.push_back(tmpMaterialDataPair);
		coloringOfSelectedPolygonSlot();
		m_poly.clear();

		for (int j = 0; j < m_elipseItemsVec.size(); ++j) {
			m_elipseItemsVecMain.push_back(QPointF(m_elipseItemsVec[j]->x(), m_elipseItemsVec[j]->y()));

		}

		for (int i = 0; i < m_elipseItemsVec.size(); ++i) {
			m_mainGraphicsScene->removeItem(m_elipseItemsVec[i]);


		}
		for (int i = 0; i < m_elipseItemsVec.size(); ++i) {
			//m_mainGraphicsScene->removeItem(m_elipseItemsVec[i]);
			delete m_elipseItemsVec[i];
		}
		m_elipseItemsVec.clear();
	}
	else if (m_selectComponentWidget->currentText() == "AccessPoint" &&  m_accessPointsWidget->exec() == QDialog::Accepted) {
		accessPointDataStr tmpAPDataStr;
	    std::pair<cv::Point, accessPointDataStr> tmpAPDataPair;

		tmpAPDataStr.m_accessPointID =  std::atoi(m_accessPointID->text().toStdString().c_str());
	    tmpAPDataStr.m_accessPointType = m_accessPointName->text().toStdString();
		tmpAPDataPair.second = tmpAPDataStr;

		tmpAPDataPair.first =  cv::Point(m_poly[m_poly.size() -1].x(), m_poly[m_poly.size() - 1].y());
		//	std::cout << tmpMaterialDataStr.m_materialID << "     " << tmpMaterialDataStr.m_materialName << "     " << tmpMaterialDataStr.m_materialTickness << "      " << tmpMaterialDataStr.m_materialType << std::endl;
		m_multiAccessPoints.push_back(tmpAPDataPair);
		coloringOfSelectedAccessPoint();
		m_poly.clear();

		for (int j = 0; j < m_elipseItemsVec.size(); ++j) {
			m_elipseItemsVecMain.push_back(QPointF(m_elipseItemsVec[j]->x(), m_elipseItemsVec[j]->y()));

		}

		/*for (int i = 0; i < m_elipseItemsVec.size(); ++i) {
			m_mainGraphicsScene->removeItem(m_elipseItemsVec[i]);


		}
		for (int i = 0; i < m_elipseItemsVec.size(); ++i) {
			//m_mainGraphicsScene->removeItem(m_elipseItemsVec[i]);
			delete m_elipseItemsVec[i];
		}
		m_elipseItemsVec.clear();*/
	}
	else
	{
	
		m_poly.clear();
		for (int i = 0; i < m_elipseItemsVec.size(); ++i) {
			m_mainGraphicsScene->removeItem(m_elipseItemsVec[i]);
		
		}
		for (int i = 0; i < m_elipseItemsVec.size(); ++i) {
			//m_mainGraphicsScene->removeItem(m_elipseItemsVec[i]);
			delete m_elipseItemsVec[i];
		}
		m_elipseItemsVec.clear();
		
		qDebug() << "Dialog closed imid";
	}
	//coloringOfSelectedPolygonSlot();
	//m_segmentDataWidget->show();
//	m_tableWidget->show();	
	//setCentralWidget(m_tableWidget);
	
}



bool FloorPlanSegmentationGui::parseHeightMapTxtFile(cv::Mat& resHeightMap, cv::Mat& resSINRMap)
{
	int number_of_lines = 0;
	int countOfColums = 0;
	std::string line;
	std::ifstream myfile("rfMapFull.txt");
	std::ifstream myfileSINR("sinrData.txt");
	
	std::vector<std::vector<int>> heighMapFileData;
	bool countOfColumscalculated = false;
	while (std::getline(myfile, line)) {
		std::vector<int> tmpLineData;
		++number_of_lines;
		std::vector<std::string> tokens;
		//if (!countOfColumscalculated) {
			//countOfColumscalculated = true;
		countOfColums = 0;
		std::string buf;                 // Have a buffer string
		std::stringstream ss(line);       // Insert the string into a stream

		//std::vector<std::string> tokens; // Create vector to hold our words

		while (ss >> buf)
			tmpLineData.push_back(std::atoi(buf.c_str()));
		if (!countOfColumscalculated) {
			countOfColums = tmpLineData.size();
		}
		else {
			if (countOfColums != tmpLineData.size()) {
				return false;
			}
		}
		heighMapFileData.push_back(tmpLineData);
				
	}
	resHeightMap = cv::Mat(number_of_lines, countOfColums, CV_32SC1);
	for (int i = 0; i < heighMapFileData.size(); ++i) {
		for (int j = 0; j < heighMapFileData[i].size(); ++j) {
			resHeightMap.at<int>(i, j) = heighMapFileData[i][j];
		}
	}
	number_of_lines = 0;
	countOfColums = 0;
   
	std::vector<std::vector<float>> sinrFileData;
	countOfColumscalculated = false;
	while (std::getline(myfileSINR, line)) {
		std::vector<float> tmpLineData;
		++number_of_lines;
		std::vector<std::string> tokens;
		//if (!countOfColumscalculated) {
		//countOfColumscalculated = true;
		countOfColums = 0;
		std::string buf;                 // Have a buffer string
		std::stringstream ss(line);       // Insert the string into a stream

										  //std::vector<std::string> tokens; // Create vector to hold our words

		while (ss >> buf)
			tmpLineData.push_back(std::atoi(buf.c_str()));
		if (!countOfColumscalculated) {
			countOfColums = tmpLineData.size();
		}
		else {
			if (countOfColums != tmpLineData.size()) {
				return false;
			}
		}
		sinrFileData.push_back(tmpLineData);

	}

	std::cout << "Parse height map image  before \n " << std::endl;
	resSINRMap = cv::Mat(number_of_lines, countOfColums, CV_32FC1);
	if (resSINRMap.cols != resHeightMap.cols || resSINRMap.rows != resHeightMap.rows) {
		return false;
	}
	for (int i = 0; i < sinrFileData.size(); ++i) {
		for (int j = 0; j < sinrFileData[i].size(); ++j) {
			resSINRMap.at<float>(i, j) = sinrFileData[i][j];
		}
	}
	std::cout << "Parse height map image \n " << std::endl;

	m_heightMapInitImage = resHeightMap.clone();
	m_sinrInitImage = resSINRMap.clone();
//	cv::imshow("HeightMapImage", m_heightMapImage);
//	cv::waitKey(0);
	return true;

//	std::cout << "Number of lines in text file: " << number_of_lines<<"\n";
	//std::cout << "Count of colums " << tokens.size() << "\n";
}



void FloorPlanSegmentationGui::findOuterContour(const cv::Mat& inputMaskImg, cv::Mat& resImg)
{
	cv::Mat grayImg;
	cv::cvtColor(inputMaskImg, grayImg, CV_BGR2GRAY);
	

	std::vector<std::vector<cv::Point> > contours;
	std::vector<cv::Vec4i> hierarchy;

	/// Detect edges using canny
//cv::Canny(grayImg, canny_output, 100, 150, 3);

	/// Find contours
	findContours(grayImg, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, cv::Point(0, 0));
	cv::Mat drawing = cv::Mat::zeros(grayImg.size(), CV_8UC3);
	for (int i = 0; i< contours.size(); i++)
	{
		//cv::Scalar color = cv::Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
		cv::Scalar color = cv::Scalar(0, 255, 0);
		drawContours(drawing, contours, i, color, 2, 8, hierarchy, 0, cv::Point());
	}
	resImg = drawing.clone();
//	cv::imshow("DrawingImag", drawing);
//	cv::waitKey(0);


}


void FloorPlanSegmentationGui::rotateCurrentPoint()
{
	cv::Mat  currentMat = QImageToCvMat(m_image, true);
	double s = std::sin(m_rotationAngle);
	double c = std::cos(m_rotationAngle);
	m_selectedPointsForGeoJson.first.x = (float)m_selectedPointsForGeoJson.first.x * c - (float)m_selectedPointsForGeoJson.first.y * s;
	m_selectedPointsForGeoJson.first.y =(float) m_selectedPointsForGeoJson.first.x * s +  (float)m_selectedPointsForGeoJson.first.y * c;
	

}

void FloorPlanSegmentationGui::rotateCurrentImage()
{
	if (m_image.height() == 0 || m_image.width() == 0) {
		return;
	}
	std::cout << "ROtating image \n";
	std::cout << "Selected image size " << m_image.height() << "    " << m_image.width() << std::endl;
	cv::Mat  currentMat = QImageToCvMat(m_image,true);
//	cv::imshow("Currentimage", currentMat);


	
	double angle = m_rotationAngle;
	/*if (m_rotationAngle > 0 ) {
		angle = 90 - m_rotationAngle;
	}
	else {
		angle = -(m_rotationAngle);
	}*/
	std::cout << "Rotation angle " << angle << std::endl;
	// get rotation matrix for rotating the image around its center in pixel coordinates
	cv::Point2f center((currentMat.cols - 1) / 2.0, (currentMat.rows - 1) / 2.0);
	cv::Mat rot = cv::getRotationMatrix2D(center, angle, 1.0);
	// determine bounding rectangle, center not relevant
	cv::Rect2f bbox = cv::RotatedRect(cv::Point2f(), currentMat.size(), angle).boundingRect2f();
	// adjust transformation matrix
	rot.at<double>(0, 2) += bbox.width / 2.0 - currentMat.cols / 2.0;
	rot.at<double>(1, 2) += bbox.height / 2.0 - currentMat.rows / 2.0;

	cv::Mat dst;
	cv::warpAffine(currentMat, dst, rot, bbox.size());

	cv::imwrite("rotatedImage.png", dst);

	
	cv::Mat temp = dst.clone(); // make the same cv::Mat
	//	if ( dst.channels() )
		//cvtColor(dst, temp, CV_BGR2RGB); // cvtColor Makes a copt, that what i need
	std::cout << "Channels copunt !!!!" << temp.channels() << std::endl;

	if (temp.channels() == 1) {
		cv::cvtColor(temp, temp, CV_GRAY2BGR);
	}
	else if ( temp.channels() == 4) {
		cv::cvtColor(temp, temp, CV_BGRA2BGR);

	}
	//	QImage dest((const uchar *)temp.data, temp.cols, temp.rows, temp.step, QImage::Format_Indexed8);
	//	dest.bits();
	//	m_image = dest;
	//}
	//else {
	m_cvImage = temp.clone();
	cv::cvtColor(temp, temp, CV_BGR2RGB);
	m_componentDetector.setCurrentImage(temp);
		QImage dest((const uchar *)temp.data, temp.cols, temp.rows, temp.step, QImage::Format_RGB888);
		dest.bits();
		m_image = dest;
//	}
	 // enforce deep copy, see documentation 
					 // of QImage::QImage ( const uchar * data, int width, int height, Format format )


	
	QList<QGraphicsItem*> all = m_mainGraphicsScene->items();

	std::cout << "After getting items " << all.size() << " \n";
	//m_mainGraphicsScene->clear();
	//if (all.size() > 0) {
	for (int i = 0; i < all.size(); i++)
	{
		QGraphicsItem *gi = all[i];
		m_mainGraphicsScene->removeItem(gi);
		//delete gi;
		m_mainGraphicsScene->update();
	}
	m_pixmapItem = new QGraphicsPixmapItem();
	m_mainGraphicsScene->addItem(m_pixmapItem);
	m_pixmapItem->setPixmap(QPixmap::fromImage(m_image));
	m_pixmapItem->setPos(0, 0);


	m_poly.clear();
	for (int i = 0; i < m_elipseItemsVec.size(); ++i) {
		m_mainGraphicsScene->removeItem(m_elipseItemsVec[i]);

	}
	for (int i = 0; i < m_elipseItemsVec.size(); ++i) {
		//m_mainGraphicsScene->removeItem(m_elipseItemsVec[i]);
		delete m_elipseItemsVec[i];
	}
	m_elipseItemsVec.clear();
	
	m_mainGraphicsScene->setSceneRect(0, 0, m_image.width(), m_image.height());

	std::cout << "Finishing rotation function " << std::endl;
}




float  FloorPlanSegmentationGui::getAngleBetweenPoints(const float& x1,const float&  y1, const float& x2,const float& y2)
{


	return std::atan2(y1 - y2, x2 - x1) * (180.0 / PI);

}


void FloorPlanSegmentationGui::findRotationAngleAndDistance(const float& latitude1, const float& longtitude1, const float& latitude2, const float& longtitude2, float& rotaionAngle, float& finalDist)
{

	float longtitudeDiff = longtitude2 - longtitude1;
	float latitudeDiff = latitude2 - latitude1;


	float sinLong1 = std::sin(longtitudeDiff*PI / 180);
	float cosLat1 = std::cos(latitude2*PI / 180);
	//	std::cout << "SINLOg1 "<<std::setprecision(10) << sinLong1 << std::endl;
	//	std::cout << "cosLat1 " << std::setprecision(10) << cosLat1 << std::endl;
	float X = sinLong1 * cosLat1;
	std::cout << std::setprecision(10) << "X is equal to " << X << std::endl;


	float Y = (std::cos(latitude1*PI / 180) * std::sin(latitude2*PI / 180)) -
		(std::sin(latitude1*PI / 180) * std::cos(latitude2*PI / 180) * std::cos(longtitudeDiff*PI / 180));

	//Rotation angle between geo points and Y axis
	rotaionAngle = std::atan2(X, Y) * radiantoDeg;

	//Rotation angle between geo points and X axis
	rotaionAngle = 90 - rotaionAngle;
	

	//float point1 =   m_poly[0].x();//
	float rotationAngleBetweenPoint  = 0;
	if (m_poly.size() >= 2) {
		rotationAngleBetweenPoint = getAngleBetweenPoints((float)(m_poly[0].x()), (float)(m_poly[0].y()), (float)(m_poly[1].x()), (float)(m_poly[1].y()));
	}
	m_selectedPointsForGeoJson.first.x = m_poly[0].x();
	m_selectedPointsForGeoJson.first.y = m_poly[0].y();

	m_selectedPointsForGeoJson.second.x = m_poly[1].x();
	m_selectedPointsForGeoJson.second.y = m_poly[1].y();
	//Rotation angle for applying on floor plan
	rotaionAngle = rotaionAngle - rotationAngleBetweenPoint;

	std::cout << std::setprecision(10) << " Y is equal to  " << Y << std::endl;
	std::cout << "Rotation angle!!!!!!!!!!!!!!!   " << rotaionAngle << std::endl;
 
	std::cout << std::setprecision(10) << " Y is equal to  " << Y << std::endl;
	std::cout << "Rotation angle   for points  !!!!!!!!!!!!!!!   " << rotationAngleBetweenPoint << std::endl;


	float distTmp1 = std::sin(latitudeDiff / 2 * PI / 180)  * std::sin(latitudeDiff / 2 * PI / 180) +
	std::cos(latitude1 * PI / 180) * std::cos(latitude2 * PI / 180) *  std::sin(longtitudeDiff  * PI / 180 / 2)
		* std::sin(longtitudeDiff * PI / 180 / 2);


	float distTmp2 = 2 * std::atan2(std::sqrt(distTmp1), std::sqrt(1- distTmp1));
	float radiusOfEarth = 6371000;
	finalDist = radiusOfEarth * distTmp2;

}

void FloorPlanSegmentationGui::generateGeojsonFile()
{



	std::string line1 = "{";
	std::string line2 = "\"type\": \"FeatureCollection\",";
	std::string line3 = "\"features\": [";
	std::string line4 = "{ \"type\": \"Feature\", \"properties\" : { \"OBJECTID\": 1, \"SHAPE_Length\" : 0.00 }, \"geometry\" : { \"type\": \"MultiPolygon\", \"coordinates\" : [[[";


	float initialLongttitude = std::atof(m_longtitudeSpinBox1->text().toStdString().c_str());
	float initialLatitude = std::atof(m_latitudeSpinBox1->text().toStdString().c_str());



	float secondLongttitude = std::atof(m_longtitudeSpinBox2->text().toStdString().c_str());
	float secondLatitude = std::atof(m_latitudeSpinBox2->text().toStdString().c_str());

	float rotationAngle;
	float realDistance;
	findRotationAngleAndDistance(initialLatitude, initialLongttitude, secondLatitude, secondLongttitude, rotationAngle, realDistance);



	std::string line5 = "[" + std::to_string(initialLongttitude) + ", " + std::to_string(initialLatitude) + "],";
	//	std::string line6 = "[-73.98197743701935, 40.7682282835967]";
	std::string line7 = "] ] ] } }]}";





	std::ofstream myfile;
	myfile.open("example.geojson");
	myfile << line1 << "\n";
	myfile << line2 << "\n";
	myfile << line3 << "\n";
	myfile << line4 << "\n";
	myfile << line5 << "\n";

	if (m_poly.size() < 2) {
		myfile << line7 << "\n";
		myfile.close();
		return;
	}
	float euqlideanDist = std::sqrt((m_poly[0].x() - m_poly[1].x())*(m_poly[0].x() - m_poly[1].x()) +
		(m_poly[0].y() - m_poly[1].y())*(m_poly[0].y() - m_poly[1].y()));
	float scalePerOneMeter = euqlideanDist / realDistance;
	//std::cout << "Euqlidean distance  " << euqlideanDist << std::endl;

	//	float initialLongttitude = -73.98397743701935;
	//	float initialLatitude = 40.7682282835967;
	for (int i = 1; i < m_poly.size(); ++i) {
		int currentX = m_poly[i].x();
		int currentY = m_poly[i].y();

		float earhRadius = 6378137;



		int distX = currentX - m_poly[0].x();
		int distY = -(currentY - m_poly[0].y());

	//	int distX = currentX - m_poly[i - 1].x();
	//	int distY = -(currentY - m_poly[i - 1].y());
		std::cout << "disttance X " << distX << std::endl;
		std::cout << "distance Y " << distY << std::endl;
		//float scalePerOneMeter = (float) 1.0 / (float) 111111.0;
		//std::cout << std::setprecision(10);
		std::cout << "scalePerMeter " << scalePerOneMeter << std::endl;
		std::cout << "Scale Value from GUI " << m_scaleValueX << std::endl;



		//	dLat = dn / R
		//		dLon = de / (R*Cos(Pi*lat / 180))
		





		float newLong;// = initialLongttitude + longtitudeX;
		float newLat;// = initialLatitude + lantitudeY;

		float distXMeter = (float)distX / (float)scalePerOneMeter;
		float distYMeter = (float)distY / (float)scalePerOneMeter;
		calculateLatAndLong(initialLatitude, initialLongttitude,distXMeter, distYMeter, newLat, newLong);
		std::cout << std::setprecision(10);
		std::cout << "PRINT Longtitude " << newLong << std::endl;
		std::cout << std::setprecision(10);
		std::cout << "Print Latitude  " << newLat << std::endl;

		std::string tmpLine = "[" + std::to_string(newLong) + "," + " " + std::to_string(newLat) + "]";
		if (i != m_poly.size() - 1) {
			tmpLine = tmpLine + ",";
		}
		std::cout << "Final line before writng into filee " << tmpLine << std::endl;
		myfile << tmpLine << "\n";
	////	initialLongttitude = newLong;
	////	initialLatitude = newLat;



	}



	//myfile << line6 << "\n";
	myfile << line7 << "\n";
	myfile.close();

}



void FloorPlanSegmentationGui::generateGeojsonFileForWalls()
{
	std::ofstream layoutTextFile;
	layoutTextFile.open("exampleLayoutFile.lay");
	layoutTextFile << "[info]\n";
	layoutTextFile << "format = cart\n";
	layoutTextFile << "version = 1.3\n";
	layoutTextFile << "type = indoor\n";
	layoutTextFile << "\n";
	layoutTextFile << "[points]\n";
	

	std::multimap<int, std::pair<int, double>> segments;
	int indexOfCurrentPoint = -1;
	std::string fullTextForPointsPositions = "";
	std::string fullTextForLines = "";
	fullTextForPointsPositions += std::to_string(indexOfCurrentPoint) + " = " + "(1.0, 1.0)\n";
	layoutTextFile << fullTextForPointsPositions;

	


	std::cout << "Geojson Generation \n";
	if ( m_multiLineWalls.size() == 0  ||  m_multiLineWalls[0].first.size() < 2) {
		return;
	}
	std::cout << "First part of geojson \n";
	if (m_multiLineWalls.size() == 0 )
	{
		return;
	}
	
	if (m_selectComponentWidget->currentText() == "Geojson")
	{
		std::cout << "Geojhson option !!!!!!!! \n";
		return;

	}
	float initialLongttitude = std::atof(m_longtitudeSpinBox1->text().toStdString().c_str());
	float initialLatitude = std::atof(m_latitudeSpinBox1->text().toStdString().c_str());



	float secondLongttitude = std::atof(m_longtitudeSpinBox2->text().toStdString().c_str());
	float secondLatitude = std::atof(m_latitudeSpinBox2->text().toStdString().c_str());

	float lastCalcPointLongtitude = secondLongttitude;
	float lastCalcPointLatitude = secondLatitude;


	float rotationAngle;
	float realDistance;
	findRotationAngleAndDistance(initialLatitude, initialLongttitude, secondLatitude, secondLongttitude, rotationAngle, realDistance);

	
	/*float euqlideanDist = std::sqrt((m_multiLineWalls[0].first[0].x() - m_multiLineWalls[0].first[1].x())*(m_multiLineWalls[0].first[0].x() - m_multiLineWalls[0].first[1].x()) +
		(m_multiLineWalls[0].first[0].y() - m_multiLineWalls[0].first[1].y())*(m_multiLineWalls[0].first[0].y() - m_multiLineWalls[0].first[1].y()));
	float scalePerOneMeter = euqlideanDist / realDistance;*/

	float euqlideanDist = std::sqrt((m_initialGeojsonPointCoord.first - m_secondGeojsonPointCoord.first)*(m_initialGeojsonPointCoord.first - m_secondGeojsonPointCoord.first) +
		(m_initialGeojsonPointCoord.second - m_secondGeojsonPointCoord.second)*(m_initialGeojsonPointCoord.second - m_secondGeojsonPointCoord.second) );
	float scalePerOneMeter = euqlideanDist / realDistance;






	int currentX = m_multiLineWalls[0].first[1].x();
	int currentY = m_multiLineWalls[0].first[1].y();

	float earhRadius = 6378137;
    

	int distX = currentX - m_multiLineWalls[0].first[0].x();
	int distY = -(currentY - m_multiLineWalls[0].first[0].y());




	float newLong;// = initialLongttitude + longtitudeX;
	float newLat;// = initialLatitude + lantitudeY;

	float distXMeter = (float)distX / (float)scalePerOneMeter;
	float distYMeter = (float)distY / (float)scalePerOneMeter;


	indexOfCurrentPoint -= 1;
	fullTextForPointsPositions = std::to_string(indexOfCurrentPoint) + " = " + "(" + std::to_string(distXMeter) + "," +  std::to_string(distYMeter) + ")\n";
    layoutTextFile << fullTextForPointsPositions;

	std::cout << "Distance from intial point " << distXMeter << "    " << distYMeter << std::endl;
	
	

	std::multimap<int, int>::iterator itSeg;
	segments.insert(std::pair<int, std::pair<int, double>>(indexOfCurrentPoint+1, std::pair<int, double>(indexOfCurrentPoint, m_wallHeightSpinBox->value())));
	//segments.insert(std::pair<int, int>(-1, -10));
	//segments.insert(std::pair<int, int>(-2, -20));
	//segments.insert(std::pair<int, int>(-1, -12));
	//for (std::multimap<int, int>::iterator it = segments.begin(); it != segments.end(); it++)
	//	std::cout <<"MAP SEGMENTS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!    "<< it->first << " :: " << it->second << std::endl;
	//std::cout << "MAps initial points !!!!!!!!!!!!!!!!!!!!!!!!!!!" << itSeg->first << std::endl;
	//layoutTextFile.close();



	std::ofstream scalePerMeterFile;
	scalePerMeterFile.open("scalePerMeter.txt");
	scalePerMeterFile << scalePerOneMeter << "\n";
	scalePerMeterFile << "real distance " << realDistance << "\n";
	scalePerMeterFile << "euqlidean distance " << euqlideanDist << "\n";
	scalePerMeterFile.close();


	std::string line1 = "{";
	std::string line2 = "\"type\": \"FeatureCollection\",";
	std::string line3 = "\"features\": [";
//	std::string line4 = "{ \"type\": \"Feature\", \"properties\" : { \"OBJECTID\": 1,  \"Material ID\": 1,  \"SHAPE_Length\" : 0.00 }, \"geometry\" : { \"type\": \"MultiPolygon\", \"coordinates\" : [[[";




	std::string line5 = "[" + std::to_string(initialLongttitude) + ", " + std::to_string(initialLatitude) + "],";
	//	std::string line6 = "[-73.98197743701935, 40.7682282835967]";
	std::string line7 = "]}";





	std::ofstream myfile;
	myfile.open("WallsData.geojson");
	myfile << line1 << "\n";
	myfile << line2 << "\n";
	myfile << line3 << "\n";
	//myfile << line4 << "\n";
	//myfile << line5 << "\n";
	std::string lineForFirstPoint = "{ \"type\": \"Feature\", \"properties\" : { \"OBJECTID\": ";
	lineForFirstPoint = lineForFirstPoint + std::to_string(long(1));
//Last working state	lineForFirstPoint = lineForFirstPoint + ", \"Material ID\": 1, \"Material type\": \"Exterior Wall\", \"Material Thickness\": 10, \"Material Name\": \"Steel\", \"SHAPE_Length\" : 0.00 }, \"geometry\" : { \"type\": \"MultiLineString\", \"coordinates\" : [[";
//	lineForFirstPoint = lineForFirstPoint + ", \"Material ID\": 1, \"SHAPE_Length\" : 0.00 }, \"geometry\" : { \"type\": \"MultiLineString\", \"coordinates\" : [[";
	lineForFirstPoint = lineForFirstPoint + ", \"Material ID\": ";
	lineForFirstPoint = lineForFirstPoint + std::to_string(long(m_multiLineWalls[0].second.m_materialID));
	lineForFirstPoint = lineForFirstPoint + ", \"Material type\": ";
	lineForFirstPoint = lineForFirstPoint +  '"' +  m_multiLineWalls[0].second.m_materialType + '"';
	lineForFirstPoint = lineForFirstPoint + ", \"Material Thickness\": ";
	lineForFirstPoint = lineForFirstPoint + std::to_string(long(m_multiLineWalls[0].second.m_materialTickness));
	lineForFirstPoint = lineForFirstPoint + ", \"Material Name\": ";
	lineForFirstPoint = lineForFirstPoint +  '"' +  m_multiLineWalls[0].second.m_materialName + '"';
	lineForFirstPoint = lineForFirstPoint + ", \"Wall Height\": ";
	lineForFirstPoint = lineForFirstPoint + '"' + std::to_string(m_multiLineWalls[0].second.m_currentWallHeight) + '"';


	lineForFirstPoint = lineForFirstPoint + ", \"SHAPE_Length\" : 0.00 }, \"geometry\" : { \"type\": \"MultiLineString\", \"coordinates\" : [[";
	
	
	
	
	lineForFirstPoint = lineForFirstPoint + line5;
	line5 = "[" + std::to_string(secondLongttitude) + ", " + std::to_string(secondLatitude) + "]";
	lineForFirstPoint = lineForFirstPoint + line5;
	lineForFirstPoint = lineForFirstPoint + "]]}}";
	if (m_multiLineWalls[0].first.size() > 2 || m_multiLineWalls.size() > 1) {
		myfile << lineForFirstPoint<<"," << "\n";
	}
	else {
		myfile << lineForFirstPoint << "\n";
	}
//	m_poly

	if (m_multiLineWalls[0].first.size() == 2 && m_multiLineWalls.size() == 1) {
		myfile << line7 << "\n";
		myfile.close();
		return;
	}




	//std::cout << "Euqlidean distance  " << euqlideanDist << std::endl;

	//	float initialLongttitude = -73.98397743701935;
	//	float initialLatitude = 40.7682282835967;
	long currentIndexForObjectId = 1;
	for (int k = 0; k < m_multiLineWalls.size(); ++k) {
		for (int i = 0; i < m_multiLineWalls[k].first.size(); ++i) {
			if (k == 0 && i == 0) {
				i = i + 1;
				continue;
			}
			int currentX = m_multiLineWalls[k].first[i].x();
			int currentY = m_multiLineWalls[k].first[i].y();

			float earhRadius = 6378137;
			//std::cout << "Current intial selected point geojson " << m_initialGeojsonPointCoord.first << "     " << m_initialGeojsonPointCoord.second << std::endl;
			//std::cout << "Current  polylines first  point geojson " << m_multiLineWalls[0].first[0].x() << "     " << m_multiLineWalls[0].first[0].y() << std::endl;




			int distX = currentX -     m_multiLineWalls[0].first[0].x();
			int distY = -(currentY -  m_multiLineWalls[0].first[0].y());

			float newLong;// = initialLongttitude + longtitudeX;
			float newLat;// = initialLatitude + lantitudeY;

			float distXMeter = (float)distX / (float)scalePerOneMeter;
			float distYMeter = (float)distY / (float)scalePerOneMeter;



			indexOfCurrentPoint -= 1;
			fullTextForPointsPositions = std::to_string(indexOfCurrentPoint) + " = " + "(" + std::to_string(distXMeter) + "," + std::to_string(distYMeter) + ")\n";
			layoutTextFile << fullTextForPointsPositions;

			segments.insert(std::pair<int, std::pair<int, double>>(indexOfCurrentPoint + 1, std::pair<int, double>(indexOfCurrentPoint, m_wallHeightSpinBox->value())));




			std::cout << "Current point distance in meters " << distXMeter << "   " << distYMeter << std::endl;

			calculateLatAndLong(initialLatitude, initialLongttitude, distXMeter, distYMeter, newLat, newLong);
			if (i == 0) {
				lastCalcPointLatitude = newLat;
				lastCalcPointLongtitude = newLong;
				continue;
			}

			std::string lineForCurrentPoint = "{ \"type\": \"Feature\", \"properties\" : { \"OBJECTID\": ";
			++currentIndexForObjectId;
			lineForCurrentPoint = lineForCurrentPoint + std::to_string(currentIndexForObjectId);
		//last working state	lineForCurrentPoint = lineForCurrentPoint + ", \"Material ID\": 1, \"Material type\": \"Exterior Wall\", \"Material Thickness\": 10, \"Material Name\": \"Steel\", \"SHAPE_Length\" : 0.00 }, \"geometry\" : { \"type\": \"MultiLineString\", \"coordinates\" : [[";


			/*New added stuff*/
			lineForCurrentPoint = lineForCurrentPoint + ", \"Material ID\": ";
			lineForCurrentPoint = lineForCurrentPoint + std::to_string(long(m_multiLineWalls[k].second.m_materialID));
			lineForCurrentPoint = lineForCurrentPoint + ", \"Material type\": ";
			lineForCurrentPoint = lineForCurrentPoint + '"' +  m_multiLineWalls[k].second.m_materialType + '"';
			lineForCurrentPoint = lineForCurrentPoint + ", \"Material Thickness\": ";
			lineForCurrentPoint = lineForCurrentPoint + std::to_string(long(m_multiLineWalls[k].second.m_materialTickness));
			lineForCurrentPoint = lineForCurrentPoint + ", \"Material Name\": ";
			lineForCurrentPoint = lineForCurrentPoint + '"' +  m_multiLineWalls[k].second.m_materialName + '"';
			lineForCurrentPoint = lineForCurrentPoint + ", \"Wall Height\": ";
			lineForCurrentPoint = lineForCurrentPoint + '"' + std::to_string(m_multiLineWalls[k].second.m_currentWallHeight) + '"';

		

			lineForCurrentPoint = lineForCurrentPoint + ", \"SHAPE_Length\" : 0.00 }, \"geometry\" : { \"type\": \"MultiLineString\", \"coordinates\" : [[";
			/*End of new added stuff*/
			std::string lineTmp = "[" + std::to_string(lastCalcPointLongtitude) + ", " + std::to_string(lastCalcPointLatitude) + "],";

			lineForCurrentPoint = lineForCurrentPoint + lineTmp;
			lineTmp = "[" + std::to_string(newLong) + ", " + std::to_string(newLat) + "]";
			lineForCurrentPoint = lineForCurrentPoint + lineTmp;
			lineForCurrentPoint = lineForCurrentPoint + "]]}}";
			if (i != m_multiLineWalls[m_multiLineWalls.size() - 1].first.size() - 1 || k != m_multiLineWalls.size() - 1) {
				
				myfile << lineForCurrentPoint << "," << "\n";
			}
			else {
				
				myfile << lineForCurrentPoint << "\n";
			}
			lastCalcPointLatitude = newLat;
			lastCalcPointLongtitude = newLong;






		}
	}

	layoutTextFile << "\n";
	layoutTextFile << "[segments]\n";
	std::string fullTextForSegments;
	unsigned int currentSegmentIndex = 1;
	int lastIndexForSegment;
	int firstIndexForSegment;
	unsigned int indexOfCurrentSegment = 0;
	int firstIndexInSegment;
	int secondIndexInSegment;
	double heightOfCurrentWall;
	for (std::multimap<int, std::pair<int,double>>::iterator it = segments.begin(); it != segments.end(); it++) {
		//	std::cout <<"MAP SEGMENTS !!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!    "<< it->first << " :: " << it->second << std::endl;
		firstIndexInSegment = it->first;
		secondIndexInSegment = it->second.first;
		
		heightOfCurrentWall = it->second.second;
		if (currentSegmentIndex == 1) {
			lastIndexForSegment = secondIndexInSegment;
		}
		fullTextForSegments = "";
		fullTextForSegments += std::to_string(currentSegmentIndex);
		++currentSegmentIndex;
		fullTextForSegments += " = {'name' : 'WALL' , 'connect': ";
		std::string currentSegmentData = "[" + std::to_string(firstIndexInSegment) + ", " + std::to_string(secondIndexInSegment) + "], 'z': [0.0, " + std::to_string(heightOfCurrentWall) + "]}";
		fullTextForSegments += currentSegmentData;
		layoutTextFile << fullTextForSegments;
		layoutTextFile << "\n";
	}


	fullTextForSegments = "";
	fullTextForSegments += std::to_string(currentSegmentIndex);
	fullTextForSegments += " = {'name' : 'WALL' , 'connect': ";
	std::string currentSegmentData = "[" + std::to_string(lastIndexForSegment) + ", " + std::to_string(firstIndexInSegment) + "], 'z': [0.0, " + std::to_string(heightOfCurrentWall) + "]}";
	fullTextForSegments += currentSegmentData;
	layoutTextFile << fullTextForSegments;
	layoutTextFile << "\n";





	layoutTextFile << "\n";
	layoutTextFile << "[files]\n";
	layoutTextFile << "furniture =\n";
	layoutTextFile << "\n";
	layoutTextFile << "[slabs]\n";

	std::string currentMaterialData = "WALL = { 'color': 'grey20', 'linewidth' : 3, 'lthick' : [0.07], 'lmatname' : ['BRICK'] }";
	layoutTextFile << currentMaterialData << "\n";
	currentMaterialData = "_AIR = { 'color': 'white', 'linewidth' : 1, 'lthick' : [0.02], 'lmatname' : ['AIR'] }";
	layoutTextFile << currentMaterialData << "\n";
	currentMaterialData = "WOOD = { 'color': 'maroon', 'linewidth' : 2, 'lthick' : [0.04], 'lmatname' : ['WOOD'] }";
	layoutTextFile << currentMaterialData << "\n";
	currentMaterialData = "METAL = { 'color': 'black', 'linewidth' : 4, 'lthick' : [0.1], 'lmatname' : ['METAL'] }";
	layoutTextFile << currentMaterialData << "\n";
	currentMaterialData = "PARTITION = { 'color': 'grey80', 'linewidth' : 4, 'lthick' : [0.1], 'lmatname' : ['PLASTER'] }";
	layoutTextFile << currentMaterialData << "\n";
	currentMaterialData = "AIR = { 'color': 'white', 'linewidth' : 1, 'lthick' : [0.02], 'lmatname' : ['AIR'] }";
	layoutTextFile << currentMaterialData << "\n";
	currentMaterialData = "CEIL = { 'color': 'grey20', 'linewidth' : 1, 'lthick' : [0.1], 'lmatname' : ['REINFORCED_CONCRETE'] }";
	layoutTextFile << currentMaterialData << "\n";
	currentMaterialData = "FLOOR = { 'color': 'grey40', 'linewidth' : 1, 'lthick' : [0.1], 'lmatname' : ['REINFORCED_CONCRETE'] }";
	layoutTextFile << currentMaterialData << "\n";
	layoutTextFile << "\n";
	currentMaterialData = "[materials]";
	layoutTextFile << currentMaterialData << "\n";
	currentMaterialData = "BRICK = { 'mur': (1 + 0j), 'epr' : (4.09999990463 + 0j), 'roughness' : 0.0, 'sigma' : 0.300000011921 }";
	layoutTextFile << currentMaterialData << "\n";
	currentMaterialData = "AIR = { 'mur': (1 + 0j), 'epr' : (1 + 0j), 'roughness' : 0.0, 'sigma' : 0.0 }";
	layoutTextFile << currentMaterialData << "\n";
	currentMaterialData = "WOOD = { 'mur': (1 + 0j), 'epr' : (2.83999991417 - 0.019999999553j), 'roughness' : 0.0, 'sigma' : 0.0 }";
	layoutTextFile << currentMaterialData << "\n";
	currentMaterialData = "PLASTER = { 'mur': (1 + 0j), 'epr' : (8 + 0j), 'roughness' : 0.0, 'sigma' : 0.038 }";
	layoutTextFile << currentMaterialData << "\n";
	currentMaterialData = "METAL = { 'mur': (1 + 1j), 'epr' : (-1 - 1j), 'roughness' : 0.0, 'sigma' : 1000.0 }";
	layoutTextFile << currentMaterialData << "\n";
	currentMaterialData = "REINFORCED_CONCRETE = { 'sigma': 3.0, 'roughness' : 0.0, 'epr' : (8.69999980927 + 0j), 'mur' : (1 + 0j) }";
	layoutTextFile << currentMaterialData << "\n";
	layoutTextFile << "\n";
	currentMaterialData = "[indoor]";
	layoutTextFile << currentMaterialData << "\n";
	currentMaterialData = "zceil = 3";
	layoutTextFile << currentMaterialData << "\n";
	currentMaterialData = "zfloor = 0";
	layoutTextFile << currentMaterialData << "\n";
	layoutTextFile.close();
	//myfile << line6 << "\n";
	myfile << line7 << "\n";
	myfile.close();

}




void FloorPlanSegmentationGui::generateGeojsonFileForRooms()
{

	if ( m_multiPolygonRooms.size() == 0 ||   m_multiLineWalls.size() == 0 || m_multiLineWalls[0].first.size() < 2) {
		return;
	}
	

	float initialLongttitude = std::atof(m_longtitudeSpinBox1->text().toStdString().c_str());
	float initialLatitude = std::atof(m_latitudeSpinBox1->text().toStdString().c_str());



	float secondLongttitude = std::atof(m_longtitudeSpinBox2->text().toStdString().c_str());
	float secondLatitude = std::atof(m_latitudeSpinBox2->text().toStdString().c_str());

	float lastCalcPointLongtitude = secondLongttitude;
	float lastCalcPointLatitude = secondLatitude;


	float rotationAngle;
	float realDistance;
	findRotationAngleAndDistance(initialLatitude, initialLongttitude, secondLatitude, secondLongttitude, rotationAngle, realDistance);


	std::string line1 = "{";
	std::string line2 = "\"type\": \"FeatureCollection\",";
	std::string line3 = "\"features\": [";
	//	std::string line4 = "{ \"type\": \"Feature\", \"properties\" : { \"OBJECTID\": 1,  \"Material ID\": 1,  \"SHAPE_Length\" : 0.00 }, \"geometry\" : { \"type\": \"MultiPolygon\", \"coordinates\" : [[[";




	std::string line5 = "[" + std::to_string(initialLongttitude) + ", " + std::to_string(initialLatitude) + "],";
	//	std::string line6 = "[-73.98197743701935, 40.7682282835967]";
	//std::string line7 = "]}";
	std::string line7 = "] ] ] } }"; 




	std::ofstream myfile;
	myfile.open("RoomsData.geojson");
	myfile << line1 << "\n";
	myfile << line2 << "\n";
	myfile << line3 << "\n";


	float euqlideanDist = std::sqrt((m_multiLineWalls[0].first[0].x() - m_multiLineWalls[0].first[1].x())*(m_multiLineWalls[0].first[0].x() - m_multiLineWalls[0].first[1].x()) +
		(m_multiLineWalls[0].first[0].y() - m_multiLineWalls[0].first[1].y())*(m_multiLineWalls[0].first[0].y() - m_multiLineWalls[0].first[1].y()));
	float scalePerOneMeter = euqlideanDist / realDistance;
	//std::cout << "Euqlidean distance  " << euqlideanDist << std::endl;

	//	float initialLongttitude = -73.98397743701935;
	//	float initialLatitude = 40.7682282835967;
	long currentIndexForObjectId = 0;
	for (int k = 0; k < m_multiPolygonRooms.size(); ++k) {
		if (m_multiPolygonRooms[k].first.size() < 3) {
			continue;
		}
		std::string lineForCurrentPoint = "{ \"type\": \"Feature\", \"properties\" : { \"OBJECTID\": ";
		++currentIndexForObjectId;
		lineForCurrentPoint = lineForCurrentPoint + std::to_string(currentIndexForObjectId);
		//last working state	lineForCurrentPoint = lineForCurrentPoint + ", \"Material ID\": 1, \"Material type\": \"Exterior Wall\", \"Material Thickness\": 10, \"Material Name\": \"Steel\", \"SHAPE_Length\" : 0.00 }, \"geometry\" : { \"type\": \"MultiLineString\", \"coordinates\" : [[";


		/*New added stuff*/
		lineForCurrentPoint = lineForCurrentPoint + ", \"Floor ID\": ";
		lineForCurrentPoint = lineForCurrentPoint + std::to_string(long(m_multiPolygonRooms[k].second.m_floorId));
		lineForCurrentPoint = lineForCurrentPoint + ", \"Room Name\": ";
		lineForCurrentPoint = lineForCurrentPoint + '"' + m_multiPolygonRooms[k].second.m_roomName + '"';
		lineForCurrentPoint = lineForCurrentPoint + ", \"Building Name\": ";
		lineForCurrentPoint = lineForCurrentPoint + '"' +  (m_multiPolygonRooms[k].second.m_buildingName) + '"';
	

		//"{ \"type\": \"Feature\", \"properties\" : { \"OBJECTID\": 1, \"SHAPE_Length\" : 0.00 }, \"geometry\" : { \"type\": \"MultiPolygon\", \"coordinates\" : [[[";

		lineForCurrentPoint = lineForCurrentPoint + ", \"SHAPE_Length\" : 0.00 }, \"geometry\" : { \"type\": \"MultiPolygon\", \"coordinates\" : [[[";

		for (int i = 0; i < m_multiPolygonRooms[k].first.size(); ++i) {
			/*if (k == 0 && i == 0) {
				i = i + 1;
				continue;
			}*/
			int currentX = m_multiPolygonRooms[k].first[i].x();
			int currentY = m_multiPolygonRooms[k].first[i].y();

			float earhRadius = 6378137;



			int distX = currentX - m_multiLineWalls[0].first[0].x();
			int distY = -(currentY - m_multiLineWalls[0].first[0].y());

			float newLong;// = initialLongttitude + longtitudeX;
			float newLat;// = initialLatitude + lantitudeY;

			float distXMeter = (float)distX / (float)scalePerOneMeter;
			float distYMeter = (float)distY / (float)scalePerOneMeter;
			calculateLatAndLong(initialLatitude, initialLongttitude, distXMeter, distYMeter, newLat, newLong);
			/*if (i == 0) {
				lastCalcPointLatitude = newLat;
				lastCalcPointLongtitude = newLong;
				continue;
			}*/

		
			/*End of new added stuff*/

			std::string tmpLine = "[" + std::to_string(newLong) + "," + " " + std::to_string(newLat) + "]";
			if (i != m_multiPolygonRooms[k].first.size() - 1) {
				tmpLine = tmpLine + ",";
			}
		/*	std::cout << "Final line before writng into filee " << tmpLine << std::endl;
			myfile << tmpLine << "\n";


			std::string lineTmp = "[" + std::to_string(lastCalcPointLongtitude) + ", " + std::to_string(lastCalcPointLatitude) + "],";*/

			lineForCurrentPoint = lineForCurrentPoint + tmpLine;
			/*lineTmp = "[" + std::to_string(newLong) + ", " + std::to_string(newLat) + "]";
			lineForCurrentPoint = lineForCurrentPoint + lineTmp;
			lineForCurrentPoint = lineForCurrentPoint + "]]}}";
			if (i != m_multiLineWalls[m_multiLineWalls.size() - 1].first.size() - 1 || k != m_multiLineWalls.size() - 1) {

				myfile << lineForCurrentPoint << "," << "\n";
			}
			else {

				myfile << lineForCurrentPoint << "\n";
			}
			lastCalcPointLatitude = newLat;
			lastCalcPointLongtitude = newLong;*/


		}
		myfile << lineForCurrentPoint;
		if (k != m_multiPolygonRooms.size() - 1) {
			myfile << line7 << "," << "\n";
		}
		else {
			myfile << line7 << "\n";
		}
	}


	//myfile << line6 << "\n";
	myfile << "]}" << "\n";
	myfile.close();



}




void FloorPlanSegmentationGui::generateGeojsonFileForAccessPoints()
{


	std::ofstream iniTextFile;
	iniTextFile.open("exampleIniFile.ini");
	std::string iniCurrentString;
	iniCurrentString = "[grid]";
	iniTextFile << iniCurrentString << "\n";
	iniCurrentString = "nx ="  + std::to_string(m_cvImage.cols/2);
	iniTextFile << iniCurrentString << "\n";
	iniCurrentString = "ny =" + std::to_string(m_cvImage.rows / 2);;
	iniTextFile << iniCurrentString << "\n";
	iniCurrentString = "boundary = [20,0,30,20]";
	iniTextFile << iniCurrentString << "\n";
	iniCurrentString = "zgrid = 1.2";
	iniTextFile << iniCurrentString << "\n";
	iniCurrentString = "mode = full";
	iniTextFile << iniCurrentString << "\n";
	iniCurrentString = "file = 'points.ini'";
	iniTextFile << iniCurrentString << "\n";
	iniTextFile << "\n";
	iniCurrentString = "[layout]";
	iniTextFile << iniCurrentString << "\n";
	iniCurrentString = "filename = exampleLayoutFile.lay\n";
	iniTextFile << iniCurrentString << "\n";
	iniCurrentString = "[ap]";
	iniTextFile << iniCurrentString << "\n";
	//iniTextFile.close();







	std::cout << "Fucntgion call start !!!!!!!!!!!!!! \n";
	if (m_multiAccessPoints.size() == 0 || m_multiLineWalls.size() == 0 || m_multiLineWalls[0].first.size() < 2) {
		return;
	}
	std::cout << "Fucntgion call second  !!!!!!!!!!!!!! \n";
	float initialLongttitude = std::atof(m_longtitudeSpinBox1->text().toStdString().c_str());
	float initialLatitude = std::atof(m_latitudeSpinBox1->text().toStdString().c_str());



	float secondLongttitude = std::atof(m_longtitudeSpinBox2->text().toStdString().c_str());
	float secondLatitude = std::atof(m_latitudeSpinBox2->text().toStdString().c_str());

	float lastCalcPointLongtitude = secondLongttitude;
	float lastCalcPointLatitude = secondLatitude;


	float rotationAngle;
	float realDistance;
	findRotationAngleAndDistance(initialLatitude, initialLongttitude, secondLatitude, secondLongttitude, rotationAngle, realDistance);


	std::string line7;

	std::string line1 = "{";
	std::string line2 = "\"type\": \"FeatureCollection\",";
	std::string line3 = "\"features\": [";
	std::cout << " start generation access points \n ";
	std::ofstream myfile;
	myfile.open("AccessPointsData.geojson");
	myfile << line1 << "\n";
	myfile << line2 << "\n";
	myfile << line3 << "\n";


	float euqlideanDist = std::sqrt((m_multiLineWalls[0].first[0].x() - m_multiLineWalls[0].first[1].x())*(m_multiLineWalls[0].first[0].x() - m_multiLineWalls[0].first[1].x()) +
		(m_multiLineWalls[0].first[0].y() - m_multiLineWalls[0].first[1].y())*(m_multiLineWalls[0].first[0].y() - m_multiLineWalls[0].first[1].y()));
	float scalePerOneMeter = euqlideanDist / realDistance;
	//std::cout << "Euqlidean distance  " << euqlideanDist << std::endl;

	//	float initialLongttitude = -73.98397743701935;
	//	float initialLatitude = 40.7682282835967;
	long currentIndexForObjectId = 0;



	for (int k = 0; k < m_multiAccessPoints.size(); ++k) {
	
		std::string lineForCurrentPoint = "{ \"type\": \"Feature\", \"properties\" : { \"OBJECTID\": ";
		++currentIndexForObjectId;
		lineForCurrentPoint = lineForCurrentPoint + std::to_string(currentIndexForObjectId);
		//last working state	lineForCurrentPoint = lineForCurrentPoint + ", \"Material ID\": 1, \"Material type\": \"Exterior Wall\", \"Material Thickness\": 10, \"Material Name\": \"Steel\", \"SHAPE_Length\" : 0.00 }, \"geometry\" : { \"type\": \"MultiLineString\", \"coordinates\" : [[";


		/*New added stuff*/
		lineForCurrentPoint = lineForCurrentPoint + ", \"Access Point ID\": ";
		lineForCurrentPoint = lineForCurrentPoint + std::to_string(long(m_multiAccessPoints[k].second.m_accessPointID));
		lineForCurrentPoint = lineForCurrentPoint + ", \"Access Point Name\": ";
		lineForCurrentPoint = lineForCurrentPoint + '"' + m_multiAccessPoints[k].second.m_accessPointType + '"';
	

		//"{ \"type\": \"Feature\", \"properties\" : { \"OBJECTID\": 1, \"SHAPE_Length\" : 0.00 }, \"geometry\" : { \"type\": \"MultiPolygon\", \"coordinates\" : [[[";

		lineForCurrentPoint = lineForCurrentPoint + ", \"SHAPE_Length\" : 0.00 }, \"geometry\" : { \"type\": \"Point\", \"coordinates\" : ";

	//	for (int i = 0; i < m_multiPolygonRooms[k].first.size(); ++i) {
			/*if (k == 0 && i == 0) {
			i = i + 1;
			continue;
			}*/
			int currentX = m_multiAccessPoints[k].first.x;
			int currentY = m_multiAccessPoints[k].first.y;

			float earhRadius = 6378137;



			int distX = currentX - m_multiLineWalls[0].first[0].x();
			int distY = -(currentY - m_multiLineWalls[0].first[0].y());

			float newLong;// = initialLongttitude + longtitudeX;
			float newLat;// = initialLatitude + lantitudeY;

			float distXMeter = (float)distX / (float)scalePerOneMeter;
			float distYMeter = (float)distY / (float)scalePerOneMeter;
			calculateLatAndLong(initialLatitude, initialLongttitude, distXMeter, distYMeter, newLat, newLong);
		     

			iniCurrentString = std::to_string(k) + " = {'name':'" + m_multiAccessPoints[k].second.m_accessPointType + "','wstd':'ieee80211b','p':(" + std::to_string(distXMeter) + "," + std::to_string(distYMeter) + ","
			+	std::to_string(m_accessPointHeightSpinBox->value()) + "),'PtdBm':0,'chan':[11],'on':True,'ant':'Omni','phideg':90}";
			iniTextFile << iniCurrentString << "\n";




			std::string tmpLine = "[" + std::to_string(newLong) + "," + " " + std::to_string(newLat) + "]";
			tmpLine = tmpLine + "}}";
			if (k != m_multiAccessPoints.size() - 1) {
				tmpLine = tmpLine + ",";
			}
			/*	std::cout << "Final line before writng into filee " << tmpLine << std::endl;
			myfile << tmpLine << "\n";


			std::string lineTmp = "[" + std::to_string(lastCalcPointLongtitude) + ", " + std::to_string(lastCalcPointLatitude) + "],";*/

			lineForCurrentPoint = lineForCurrentPoint + tmpLine;
		


	//	}
		myfile << lineForCurrentPoint<<"\n";
		/*if (k != m_multiPolygonRooms.size() - 1) {
			myfile << line7 << "," << "\n";
		}
		else {
			myfile << line7 << "\n";
		}*/
	}
	iniTextFile << "\n";
	iniTextFile << "[rx]\n";
	iniTextFile << "temperaturek = 300 \n";
	iniTextFile << "noisefactordb = 0 \n";
	iniTextFile << "\n";
	iniTextFile << "[show] \n";
	iniTextFile << "show = True \n";
	iniTextFile.close();

	//myfile << line6 << "\n";
	myfile << "]}" << "\n";
	myfile.close();

}



void FloorPlanSegmentationGui::calculateLatAndLong(const float& initLat, const float& initLong, const float&  meterPerX, const float& meterPerY, float& finalLat, float& finalLong)
{


	

	//Earth’s radius, sphere
 //   float R = 6378137;
	
	float R = 6371000;
	//offsets in meters



	float de = meterPerX;// 62.5;
	float dn = meterPerY;//  110.96;

						 //Coordinate offsets in radians
	float dLat = dn / R;
	float dLon = de / (R*std::cos(PI*initLat / 180));

	//OffsetPosition, decimal degrees
	finalLat = initLat + dLat * 180 / PI;
	finalLong = initLong + dLon * 180 / PI;


}




void FloorPlanSegmentationGui::drawHeightMapValue()
{
	QPoint tmpMovePoint  = m_mainGraphicsScene->transferMovedPointsPosition();
	//m_graphicsTextItem->setRect(tmpMovePoint.x(), tmpMovePoint.y(),10,10);
	//m_mainGraphicsScene->addItem(m_graphicsTextItem);
	m_graphicsTextItem->setPos(tmpMovePoint.x(), tmpMovePoint.y());
	m_graphicsTextItem->setScale(2);
	QString tmpPositon = QString(std::to_string(tmpMovePoint.x()).c_str()) + "  " +  QString(std::to_string(tmpMovePoint.y()).c_str());
	if (tmpMovePoint.x() < m_image.width() && tmpMovePoint.y() < m_image.height()  /*&&  m_roomTypeComboBoBox->currentText() == "HeightMap"*/) {
		cv::Mat heightMap;
		cv::Mat sinrMap;
		if (m_DbmShowingButton->isChecked()  /*&&  parseHeightMapTxtFile(heightMap,sinrMap) */) {

			if (m_heightMapInitImage.cols == 0 || m_heightMapInitImage.rows == 0) {
				cv::Mat resHeightMapImage;
				cv::Mat resSinrMapImage;
				parseHeightMapTxtFile(resHeightMapImage, resSinrMapImage);
			}


			std::cout << "CALLED DBM SHOW BUTTON \n";
			if ( m_heightMapInitImage.rows == m_image.height() && m_heightMapInitImage.cols == m_image.width() ) {
				std::cout << "FINAL HEIGHTMAPPPPPPPPPPPPPPPPPPP \n";
				//m_graphicsTextItem->setRect(tmpMovePoint.x(), tmpMovePoint.y(),10,10);
				tmpPositon = QString(std::to_string(m_heightMapInitImage.at<int>(tmpMovePoint.y(), tmpMovePoint.x())).c_str()) + " Dbm";
				m_graphicsTextItem->setPlainText(tmpPositon);
				//m_graphicsTextItem->setItemTitle
				m_mainGraphicsScene->addItem(m_graphicsTextItem);
				//std::cout << m_roomTypeComboBoBox->currentText().toStdString() << std::endl;
			}
		}
		else if (m_SinrShowingButton->isChecked() /*&& parseHeightMapTxtFile(heightMap, sinrMap)*/) {
			if (m_sinrInitImage.rows == m_image.height() && m_sinrInitImage.cols == m_image.width()) {
				std::cout << "FINAL HEIGHTMAPPPPPPPPPPPPPPPPPPP  SINR\n";
				//m_graphicsTextItem->setRect(tmpMovePoint.x(), tmpMovePoint.y(),10,10);
				tmpPositon = QString(std::to_string(m_sinrInitImage.at<float>(tmpMovePoint.y(), tmpMovePoint.x())).c_str()) + " DB";
				m_graphicsTextItem->setPlainText(tmpPositon);
				//m_graphicsTextItem->setItemTitle
				m_mainGraphicsScene->addItem(m_graphicsTextItem);
				//std::cout << m_roomTypeComboBoBox->currentText().toStdString() << std::endl;
			}
		}
		else if (!m_SinrShowingButton->isChecked() && !m_DbmShowingButton->isChecked()) {
			m_mainGraphicsScene->removeItem(m_graphicsTextItem);
		}
		
	//	std::cout << m_roomTypeComboBoBox->currentText().toStdString() << "\n";

//		m_graphicsTextItem->setPlainText(tmpPositon);
//		m_mainGraphicsScene->addItem(m_graphicsTextItem);
		//std::cout << m_roomTypeComboBoBox->currentText().toStdString() << std::endl;
	}
	else {

		QList<QGraphicsItem*> all = m_mainGraphicsScene->items();

		std::cout << "After getting items " << all.size() << " \n";
		//m_mainGraphicsScene->clear();
		//if (all.size() > 0) {
		for (int i = 0; i < all.size(); i++)
		{
			QGraphicsItem *gi = all[i];
			QGraphicsTextItem* tmpItem = dynamic_cast<QGraphicsTextItem*>(gi);
			if (tmpItem) {
				m_mainGraphicsScene->removeItem(gi);
				//delete gi;
				m_mainGraphicsScene->update();
			}
		}
	//	tmpPositon = QString("-90") + QString(" Dbm");
	//	m_graphicsTextItem->setPlainText(tmpPositon);
	//	m_mainGraphicsScene->addItem(m_graphicsTextItem);
	}




}



void FloorPlanSegmentationGui::drawCurrentRectangle()
{
	if (!m_WallRemoveCheckbox->isChecked()) {
		return;
	}

	QList<QGraphicsItem*> all = m_mainGraphicsScene->items();

	std::cout << "After getting items " << all.size() << " \n";
	//m_mainGraphicsScene->clear();
	//if (all.size() > 0) {
	for (int i = 0; i < all.size(); i++)
	{
		QGraphicsItem *gi = all[i];

		if (gi->type() == QGraphicsRectItem::Type) {


			m_mainGraphicsScene->removeItem(gi);
			//delete gi;
			m_mainGraphicsScene->update();
		}
	}



	QGraphicsRectItem* tmpRectItem = new QGraphicsRectItem;
	QBrush tmpRectBrush = QBrush(QColor(Qt::transparent));
	QPen tmpRectPen = QPen(QColor(255, 0, 0));
	
	tmpRectItem->setPen(tmpRectPen);
	tmpRectItem->setBrush(QBrush(QColor(Qt::transparent)));

	tmpRectItem->setRect(m_mainGraphicsScene->returnSelectedRectangle());
	m_mainGraphicsScene->addItem(tmpRectItem);
	m_mainGraphicsScene->update();
}

void FloorPlanSegmentationGui::drawSelectedRectangle()
{
	if (!m_WallRemoveCheckbox->isChecked()) {
		return;
	}

	QList<QGraphicsItem*> all = m_mainGraphicsScene->items();

	std::cout << "After getting items " << all.size() << " \n";
	//m_mainGraphicsScene->clear();
	//if (all.size() > 0) {
	for (int i = 0; i < all.size(); i++)
	{
		QGraphicsItem *gi = all[i];

		if (gi->type() == QGraphicsRectItem::Type) {


			m_mainGraphicsScene->removeItem(gi);
			//delete gi;
			m_mainGraphicsScene->update();
		}
	}



	QGraphicsRectItem* tmpRectItem = new QGraphicsRectItem;
	tmpRectItem->setBrush(QBrush(QColor(Qt::cyan)));
	tmpRectItem->setRect(m_mainGraphicsScene->returnSelectedRectangle());
	m_mainGraphicsScene->addItem(tmpRectItem);
	removeWallComponentsByUser();
	//m_mainGraphicsScene->addRect(m_mainGraphicsScene->returnSelectedRectangle());
	m_mainGraphicsScene->update();

}


bool FloorPlanSegmentationGui::eventFilter(QEvent *event)
{
	if (event->type() == QEvent::Close) {
		emit WidgetClosed();
		event->accept();
		//coloringOfSelectedPolygonSlot();
		m_poly.clear();
	}
	return false;
}


/*
bool FloorPlanSegmentationGui::eventFilter(QObject * obj, QEvent * ev)
{
	if (obj == m_mainGraphicsView)
		if (ev->type() == QEvent::MouseMove)
		{
			QMouseEvent *mEvent = (QMouseEvent*)ev;
			qDebug() << "Mouse move event!!!!!!!!!!!!!!!";
		}
	return false;
}
*/






void FloorPlanSegmentationGui::coloringOfSelectedWalls()
{
	QBrush brush;
	brush.setColor(Qt::green);
	
	brush.setStyle(Qt::SolidPattern);
	QPen pen(Qt::green);


	if (m_roomColorComboBox->currentText() == "Red") {
		brush.setColor(Qt::red);
		pen.setColor(Qt::red);
	}
	else if (m_roomColorComboBox->currentText() == "Green") {
		brush.setColor(Qt::green);
		pen.setColor(Qt::green);
	}
	else if (m_roomColorComboBox->currentText() == "Yellow") {
		brush.setColor(Qt::yellow);
		pen.setColor(Qt::yellow);
	}
	else if (m_roomColorComboBox->currentText() == "Blue") {
		brush.setColor(Qt::blue);
		pen.setColor(Qt::blue);
	}
	else if (m_roomColorComboBox->currentText() == "Black") {
		brush.setColor(Qt::black);
		pen.setColor(Qt::black);
	}
	else if (m_roomColorComboBox->currentText() == "Gray") {
		brush.setColor(Qt::gray);
		pen.setColor(Qt::gray);
	}
	else if (m_roomColorComboBox->currentText() == "DarkRed") {
		brush.setColor(Qt::darkRed);
		pen.setColor(Qt::darkRed);
	}
	else if (m_roomColorComboBox->currentText() == "DarkGreen") {
		brush.setColor(Qt::darkGreen);
		pen.setColor(Qt::darkGreen);
	}
	else if (m_roomColorComboBox->currentText() == "DarkBlue") {
		brush.setColor(Qt::darkBlue);
		pen.setColor(Qt::darkBlue);
	}
	else if (m_roomColorComboBox->currentText() == "DarkYellow") {
		brush.setColor(Qt::darkYellow);
		pen.setColor(Qt::darkYellow);
	}

	pen.setBrush(brush);
	pen.setWidth(5);
	for (int i = 0; i < m_poly.size()-1; ++i) {
		QLineF tmpLine;
		tmpLine.setLine(m_poly[i].x(), m_poly[i].y(), m_poly[i + 1].x(), m_poly[i + 1].y());
		//tmpLine.y1 = m_poly[i].y();
	//	tmpLine.x2 = m_poly[i+1].x();
		//tmpLine.y2 = m_poly[i+1].y();
		m_mainGraphicsScene->addLine(tmpLine, pen);
	}

}

void FloorPlanSegmentationGui::coloringOfSelectedAccessPoint()
{
	
	QGraphicsEllipseItem* elipseItem = new QGraphicsEllipseItem;
	std::cout << "Final coloring stuff \n";
	QBrush brush;
	QPen pen;
	//if (if  m_) {

	//}
	if (m_roomColorComboBox->currentText() == "Red") {
		brush.setColor(Qt::red);
		pen.setColor(Qt::red);
	}
	else if (m_roomColorComboBox->currentText() == "Green") {
		brush.setColor(Qt::green);
		pen.setColor(Qt::green);
	}
	else if (m_roomColorComboBox->currentText() == "Yellow") {
		brush.setColor(Qt::yellow);
		pen.setColor(Qt::yellow);
	}
	else if (m_roomColorComboBox->currentText() == "Blue") {
		brush.setColor(Qt::blue);
		pen.setColor(Qt::blue);
	}
	else if (m_roomColorComboBox->currentText() == "Black") {
		brush.setColor(Qt::black);
		pen.setColor(Qt::black);
	}
	else if (m_roomColorComboBox->currentText() == "Gray") {
		brush.setColor(Qt::gray);
		pen.setColor(Qt::gray);
	}
	else if (m_roomColorComboBox->currentText() == "DarkRed") {
		brush.setColor(Qt::darkRed);
		pen.setColor(Qt::darkRed);
	}
	else if (m_roomColorComboBox->currentText() == "DarkGreen") {
		brush.setColor(Qt::darkGreen);
		pen.setColor(Qt::darkGreen);
	}
	else if (m_roomColorComboBox->currentText() == "DarkBlue") {
		brush.setColor(Qt::darkBlue);
		pen.setColor(Qt::darkBlue);
	}
	else if (m_roomColorComboBox->currentText() == "DarkYellow") {
		brush.setColor(Qt::darkYellow);
		pen.setColor(Qt::darkYellow);
	}

	elipseItem->setRect(m_poly[m_poly.size() - 1].x() - 5, m_poly[m_poly.size() - 1].y() - 5, 10, 10);
	elipseItem->setPen(pen);
	elipseItem->setBrush(brush);


	brush.setStyle(Qt::SolidPattern);
	//m_mainGraphicsScene->add

    m_mainGraphicsScene->addItem(elipseItem);
	m_elipseItemsVec.push_back(elipseItem);
	m_poly.clear();


}


void FloorPlanSegmentationGui::coloringOfSelectedPolygonSlot()
{
	std::cout << "Final coloring stuff \n";
	QBrush brush;
	QPen pen;
	//if (if  m_) {

	//}
	if (m_roomColorComboBox->currentText() == "Red") {
		brush.setColor(Qt::red);
		pen.setColor(Qt::red);
	}
	else if (m_roomColorComboBox->currentText() == "Green") {
		brush.setColor(Qt::green);
		pen.setColor(Qt::green);
	}
	else if (m_roomColorComboBox->currentText() == "Yellow") {
		brush.setColor(Qt::yellow);
		pen.setColor(Qt::yellow);
	}
	else if (m_roomColorComboBox->currentText() == "Blue") {
		brush.setColor(Qt::blue);
		pen.setColor(Qt::blue);
	}
	else if (m_roomColorComboBox->currentText() == "Black") {
		brush.setColor(Qt::black);
		pen.setColor(Qt::black);
	}
	else if (m_roomColorComboBox->currentText() == "Gray") {
		brush.setColor(Qt::gray);
		pen.setColor(Qt::gray);
	}
	else if (m_roomColorComboBox->currentText() == "DarkRed") {
		brush.setColor(Qt::darkRed);
		pen.setColor(Qt::darkRed);
	}
	else if (m_roomColorComboBox->currentText() == "DarkGreen") {
		brush.setColor(Qt::darkGreen);
		pen.setColor(Qt::darkGreen);
	}
	else if (m_roomColorComboBox->currentText() == "DarkBlue") {
		brush.setColor(Qt::darkBlue);
		pen.setColor(Qt::darkBlue);
	}
	else if (m_roomColorComboBox->currentText() == "DarkYellow") {
		brush.setColor(Qt::darkYellow);
		pen.setColor(Qt::darkYellow);
	}

	brush.setStyle(Qt::SolidPattern);	
	m_mainGraphicsScene->addPolygon(m_poly, pen, brush);	
	m_poly.clear();

}


void FloorPlanSegmentationGui::onRemoveLastSelectedPoint()
{

	std::cout << "Calling remove last item function \n";
	if (m_selectComponentWidget->currentText() != "HeightMap" &&  m_selectComponentWidget->currentText() != "Geojson") {
		if (m_elipseItemsVec.size() > 0) {
			m_poly.pop_back();
			m_mainGraphicsScene->removeItem(m_elipseItemsVec[m_elipseItemsVec.size() - 1]);
			m_elipseItemsVec.pop_back();
			m_mainGraphicsScene->update();
		}
	}
	else if (m_selectComponentWidget->currentText() == "Geojson") {

	}
	else {
	//	m_mainGraphicsScene->removeItem(m_graphicsRectItem);
		QGraphicsRectItem* graphicsRectItem = new QGraphicsRectItem;
		//QGraphicsEllipseItem* elipseItemForAxisPoint =  new QGraphicsEllipseItem;
		


		QRectF tmpRect;
		
		QPoint selectedPoint = m_mainGraphicsScene->transferPickedPointsPosition();



		std::string imageSizeFileName = "imageSize.txt";
		std::ofstream fileSize;
		fileSize.open(imageSizeFileName,std::ios::app);
		fileSize << m_image.width() << " " << m_image.height() << " " << selectedPoint.x() << " " << selectedPoint.y() << "\n";
		fileSize.close();
		m_isSelectedAxisPoint = true;


		tmpRect.setX(selectedPoint.x()-10);
		tmpRect.setY (selectedPoint.y()-10);
		tmpRect.setWidth(20);
		tmpRect.setHeight(10);
	////	m_graphicsRectItem->setRect(tmpRect);
	


		m_elipseItemForAxisPoint = NULL;
		delete m_elipseItemForAxisPoint;
		m_elipseItemForAxisPoint = new QGraphicsEllipseItem;



		m_elipseItemForAxisPoint->setRect(selectedPoint.x()-10, selectedPoint.y()-10, 20, 20);
		//elipseItemForAxisPoint->set
		graphicsRectItem->setRect(tmpRect);
	


		QBrush brush;
		brush.setColor(Qt::blue);
		brush.setStyle(Qt::SolidPattern);

		QPen pen(Qt::blue);
		pen.setBrush(brush);
		pen.setWidth(5);
		//QLineF tmpLine;
		////m_graphicsRectItem->setPen(pen);
		graphicsRectItem->setPen(pen);

		
		m_elipseItemForAxisPoint->setPen(pen);
		m_elipseItemForAxisPoint->setBrush(brush);


		///m_mainGraphicsScene->addItem(m_graphicsRectItem);
		m_mainGraphicsScene->addItem(m_elipseItemForAxisPoint);
		m_mainGraphicsScene->update();
	}

	

}


void FloorPlanSegmentationGui::dbmShowingSlot()
{

	if (!m_isDbmBoxChecked) {
		m_DbmShowingButton->setChecked(true);
		m_SinrShowingButton->setChecked(false);
		m_isDbmBoxChecked = true;
		this->update();
		
	}
	else {
		m_isDbmBoxChecked = false;
		m_DbmShowingButton->setChecked(false);
		this->update();
	}
	/*if (m_DbmShowingButton->isChecked()) {
		m_DbmShowingButton->setChecked(false);
	}
	else {
		m_DbmShowingButton->setChecked(true);
	}
	m_SinrShowingButton->setChecked(false);*/
}


void FloorPlanSegmentationGui::sinrShowingSlot()
{

	if (!m_isSinrBoxChecked) {
		m_SinrShowingButton->setChecked(true);
		m_DbmShowingButton->setChecked(false);
		m_isSinrBoxChecked = true;
		this->update();
	}
	else {
		m_isSinrBoxChecked = false;
		m_SinrShowingButton->setChecked(false);
		this->update();
	}

	/*m_DbmShowingButton->setChecked(false);
	
	if (m_SinrShowingButton->isChecked()) {
		m_SinrShowingButton->setChecked(false);
	} else {
		m_SinrShowingButton->setChecked(true);
	}*/
//	m_SinrShowingButton->setChecked(true);
}




void FloorPlanSegmentationGui::removingSelectedPointsSlot()
{
	;
}



FloorPlanSegmentationGui::~FloorPlanSegmentationGui()
{

}
