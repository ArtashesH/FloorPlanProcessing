#include <QFileDialog>
#include <QGraphicsView>
#include <QLineEdit>

#include <QComboBox>



#include <QMouseEvent>
#include <QGraphicsPixmapItem>
#include <QGraphicsItem>
#include <QDebug>
#include <QGraphicsSceneMouseEvent>
#include <QHeaderView>



//#include <Python.h>
#include <string>
#include <iomanip>
#include <fstream>



#include "floorplansegmentationgui.h"


cv::RNG rng(12345);


FloorPlanSegmentationGui::FloorPlanSegmentationGui(QWidget *parent)
	: QMainWindow(parent)
{


	std::string filename = "testHeightMapData.xml";
	cv::FileStorage fs(filename, cv::FileStorage::WRITE);
	fs.release();




	std::string filename1 = "testHeightMapDataAutoGenerated.xml";
	cv::FileStorage fs1(filename1, cv::FileStorage::WRITE);
	fs1.release();




	m_countOfHeightMapPoints = 0;
	m_mainWidget = new QWidget;
	m_segmentDataWidget = new QWidget;
	m_parametersWidget = new QDialog();
	m_parametersWidget->installEventFilter(this);
	m_isSelectedAxisPoint = false;

	//QString filename = "E:/upworkProjs/FloorPlanAnalyzing/Venue_Images/TuckerStadium/APLayout.PNG";
	//QImage image(filename);

	m_mainGraphicsScene = new CustomScene();
	m_mainGraphicsScene->setSceneRect(0, 0, 1000, 1000);


	QPolygonF poly;
	poly << QPointF(10, 10) << QPointF(10, 50) << QPointF(30, 70) << QPointF(60, 50) << QPointF(50, 10);
	QBrush brush;
	brush.setColor(Qt::green);
	brush.setStyle(Qt::SolidPattern);
	
	QPen pen(Qt::green);
	QGraphicsScene graphics_scene_ = new QGraphicsScene(0, 0, 200, 200);
	//m_mainGraphicsScene->addPolygon(poly, pen, brush);
	//setScene(graphics_scene_);

	m_mainGraphicsView = new QGraphicsView(m_mainGraphicsScene);
	m_mainGraphicsView->setAlignment(Qt::AlignLeft | Qt::AlignTop);
	m_mainGraphicsView->setMouseTracking(true);


	m_selectImageButton = new QPushButton("Select Image");
	m_runSegmentationButton = new QPushButton("Run Segmentation");
	m_runHeightMapGenerationButton = new QPushButton("Run HeighMap Generation");
	m_runHeightMapGenerationButton->setEnabled(false);
	m_runComponentsDetectionButton = new QPushButton("Run Components Detection");
	m_runResetButton = new QPushButton("Reset");


	m_applyHeightMapData = new QPushButton("ApplyHeightMapSlection");
	m_applyHeightMapData->setEnabled(false);

	m_pixmapItem = new QGraphicsPixmapItem(/*QPixmap::fromImage(image)*/);
	m_mainGraphicsScene->addItem(m_pixmapItem);
	m_pixmapItem->setPos(0, 0);
	

	m_indexOfPolygonPoint = 0;
	m_lineForTypeOfRoom =  new QLineEdit;

	//m_segmentDataWidget->addAction(m_lineForTypeOfRoom);

	QVBoxLayout* layoutForParameterWidget = new QVBoxLayout;

	QPushButton *btn1 = new QPushButton("Apply");

    m_tableWidget = new QTableWidget;
	m_tableWidget->setObjectName("ParametersTableWidget");
	m_tableWidget->setRowCount(6);
	m_tableWidget->setColumnCount(6);
	m_tableWidget->setColumnWidth(0, 150);
	m_tableWidget->setColumnWidth(1, 150);
	m_tableWidget->setColumnWidth(2, 150);
	m_tableWidget->setColumnWidth(3, 150);
	m_tableWidget->setColumnWidth(4, 150);
	m_tableWidget->setColumnWidth(5, 150);
	//m_tableWidget->setColumnWidth(6, 150);

	m_DbmShowingButton = new QCheckBox("Show Dbm values");
	m_SinrShowingButton = new QCheckBox("Show Sinr values");
	m_contourShowingButton = new QCheckBox("Show HeightMap Contour");
	m_isDbmBoxChecked = false;
	m_isSinrBoxChecked = false;

	m_selectComponentWidget = new QComboBox();
	m_selectComponentWidget->setFixedSize(100, 25);
	m_selectComponentWidget->addItem("Room");
	m_selectComponentWidget->addItem("Window");
	m_selectComponentWidget->addItem("Door");
	m_selectComponentWidget->addItem("Wall");
	m_selectComponentWidget->addItem("HeightMap");
	m_selectComponentWidget->addItem("Geojson");
	
	


	m_roomColorComboBox = new QComboBox();
	m_roomColorComboBox->addItem("Green");
	m_roomColorComboBox->addItem("Yellow");
	m_roomColorComboBox->addItem("Red");
	m_roomColorComboBox->addItem("Gray");
	m_roomColorComboBox->addItem("Black");
	m_roomColorComboBox->addItem("Blue");
	m_roomColorComboBox->addItem("DarkRed");
	m_roomColorComboBox->addItem("DarkGreen");
	m_roomColorComboBox->addItem("DarkBlue");
	m_roomColorComboBox->addItem("DarkYellow");
	


//	m_rotationAngleSpinBox = new QSpinBox();
//	m_rotationAngleSpinBox->setMinimum(-360);
//	m_rotationAngleSpinBox->setMaximum(360);


	m_latitudeSpinBox1 = new QDoubleSpinBox();
	m_latitudeSpinBox1->setDecimals(20);
	m_latitudeSpinBox1->setMinimum(-1000);;
	m_latitudeSpinBox1->setMaximum(1000);

	m_latitudeSpinBox2 = new QDoubleSpinBox();
	m_latitudeSpinBox2->setDecimals(20);
	m_latitudeSpinBox2->setMinimum(-1000);;
	m_latitudeSpinBox2->setMaximum(1000);





	
	m_longtitudeSpinBox1 = new QDoubleSpinBox();
	m_longtitudeSpinBox1->setDecimals(20);
	m_longtitudeSpinBox1->setMinimum(-1000);
	m_longtitudeSpinBox1->setMaximum(1000);



	m_longtitudeSpinBox2 = new QDoubleSpinBox();
	m_longtitudeSpinBox2->setDecimals(20);
	m_longtitudeSpinBox2->setMinimum(-1000);
	m_longtitudeSpinBox2->setMaximum(1000);



	m_scaleValueSpinBoxX = new QDoubleSpinBox();
	m_scaleValueSpinBoxY = new QDoubleSpinBox();
	


	m_tableWidget->setCellWidget(0, 1, m_roomColorComboBox);
//	m_tableWidget->setCellWidget(2, 1, m_rotationAngleSpinBox);
	m_tableWidget->setCellWidget(2, 1, m_longtitudeSpinBox1);
	m_tableWidget->setCellWidget(3, 1, m_latitudeSpinBox1);
	m_tableWidget->setCellWidget(4, 1, m_longtitudeSpinBox2);
	m_tableWidget->setCellWidget(5, 1, m_latitudeSpinBox2);
//	m_tableWidget->setCellWidget(7, 1, m_scaleValueSpinBoxX);
//	m_tableWidget->setCellWidget(8, 1, m_scaleValueSpinBoxY);
	//m_tra

	//m_isPythonModuleInitialized = false;
	m_graphicsRectItem = new QGraphicsRectItem;







	m_graphicsTextItem = new QGraphicsTextItem;
	
	m_graphicsTextItem->setDefaultTextColor(QColor(0, 255, 0));


	m_elipseItemForAxisPoint = new QGraphicsEllipseItem;
	


	QTableWidgetItem *item = new QTableWidgetItem("Color", QTableWidgetItem::Type);
	item->setFlags(item->flags() ^ Qt::ItemIsEditable);
	m_tableWidget->setItem(0, 0, item);



	/*QTableWidgetItem *item2 = new QTableWidgetItem("Rotation Angle", QTableWidgetItem::Type);
	item2->setFlags(item2->flags() ^ Qt::ItemIsEditable);
	m_tableWidget->setItem(2, 0, item2);

	*/

	QTableWidgetItem *item3 = new QTableWidgetItem("Initial Longtitude1", QTableWidgetItem::Type);
	m_tableWidget->setMinimumWidth(500);
	
	item3->setFlags(item3->flags() ^ Qt::ItemIsEditable);
	m_tableWidget->setItem(2, 0, item3);

	QTableWidgetItem *item4 = new QTableWidgetItem("Initial Latitude1", QTableWidgetItem::Type);
	item4->setFlags(item4->flags() ^ Qt::ItemIsEditable);
	m_tableWidget->setItem(3, 0, item4);




	QTableWidgetItem *item5 = new QTableWidgetItem("Initial Longtitude2", QTableWidgetItem::Type);
	item5->setFlags(item5->flags() ^ Qt::ItemIsEditable);
	m_tableWidget->setItem(4, 0, item5);

	QTableWidgetItem *item6 = new QTableWidgetItem("Initial Latitude2", QTableWidgetItem::Type);
	item6->setFlags(item6->flags() ^ Qt::ItemIsEditable);
	m_tableWidget->setItem(5, 0, item6);



	/*QTableWidgetItem *item7 = new QTableWidgetItem("Scale Value X", QTableWidgetItem::Type);
	item7->setFlags(item7->flags() ^ Qt::ItemIsEditable);
	m_tableWidget->setItem(7, 0, item7);


	QTableWidgetItem *item8 = new QTableWidgetItem("Scale Value Y", QTableWidgetItem::Type);
	item8->setFlags(item8->flags() ^ Qt::ItemIsEditable);
	m_tableWidget->setItem(8, 0, item8);
	*/
   
	QTableWidgetItem *item1 = new QTableWidgetItem("Name of Room", QTableWidgetItem::Type);
	item1->setFlags(item1->flags() ^ Qt::ItemIsEditable);
	m_tableWidget->setItem(1, 0, item1);

	m_tableWidget->verticalHeader()->setVisible(false);
	m_tableWidget->horizontalHeader()->setVisible(false);


	
	layoutForParameterWidget->addWidget(m_tableWidget);
	layoutForParameterWidget->addWidget(btn1);

	m_parametersWidget->setLayout(layoutForParameterWidget);



	std::string imageSizeFileName = "imageSize.txt";
	std::ofstream fileSize;
	fileSize.open(imageSizeFileName);
	fileSize.close();

	/*QLineEdit *le = new QLineEdit;
	le->setProperty("row", 0);
	le->setProperty("column", 0);
	m_tableWidget->setCellWidget(0, 0, le);
	m_tableWidget->setCellWidget(0, 1, le);
	*/


	/*PyObject* pName;

	Py_Initialize();

	pName = PyUnicode_FromString("MainRf_rayTracingCurrentState");
	


	m_pModule = PyImport_Import(pName);
	
	m_pFunc = PyObject_GetAttrString(m_pModule, "finalFunctionHeightMap");
	std::cout << "before crash \n";
	//	}
	std::cout << "Prepare for python call111111111111111111111 !!!!! \n";
	Py_DECREF(pName);*/


	//m_tableWidget->setFlags(Qt::ItemIsUserCheckable);
	//m_tableWidget->setCheckState(Qt::Unchecked);
	//tableWidget->setItem(row, column, item);



	m_selectSegmentLayout = new QHBoxLayout();
	m_selectSegmentLayout->addWidget(m_selectImageButton);
	m_selectSegmentLayout->addWidget(m_runSegmentationButton);
	m_selectSegmentLayout->addWidget(m_runHeightMapGenerationButton);
	m_selectSegmentLayout->addWidget(m_runComponentsDetectionButton);
	m_selectSegmentLayout->addWidget(m_runResetButton);


	m_mainLayout= new QVBoxLayout();
	m_mainLayout->addWidget(m_selectComponentWidget);
	m_mainLayout->addWidget(m_DbmShowingButton);
	m_mainLayout->addWidget(m_SinrShowingButton);
	m_mainLayout->addWidget(m_contourShowingButton);
	m_mainLayout->addWidget(m_applyHeightMapData);
	m_mainLayout->addWidget(m_mainGraphicsView);
	m_mainLayout->addLayout(m_selectSegmentLayout);
/////	m_mainLayout->addWidget(m_selectImageButton);
/////	m_mainLayout->addWidget(m_runSegmentationButton);
////	m_mainLayout->addWidget(m_runHeightMapGenerationButton);

	//QWidget * w = new QWidget();
	m_mainWidget->setLayout(m_mainLayout);


	ui.setupUi(this);
	this->setCentralWidget(m_mainWidget);
	connect(m_selectImageButton, SIGNAL(clicked()), this, SLOT(setSelectedImagePath()));
	connect(m_runSegmentationButton, SIGNAL(clicked()), this, SLOT(runSegmentation()));
	connect(m_runHeightMapGenerationButton, SIGNAL(clicked()), this, SLOT(runHeightMapGeneration()));
	connect(m_mainGraphicsScene, SIGNAL(selectPointOnScene()), SLOT(getSelectedPoints()));
	connect(m_mainGraphicsScene, SIGNAL(finishSelectingPoints()), SLOT(drawPolygonFromSelectedPoints()));
	connect(m_mainGraphicsScene, SIGNAL(selectMovedPoint()), SLOT(drawHeightMapValue()));
	connect(m_mainGraphicsScene, SIGNAL(removeLastSelectedPoint()), SLOT(onRemoveLastSelectedPoint()));
    //connect(m_parametersWidget, SIGNAL(WidgetClosed()),  SLOT(coloringOfSelectedPolygonSlot()));
	connect(btn1, &QPushButton::clicked, m_parametersWidget, &QDialog::accept);
	connect(m_DbmShowingButton, SIGNAL(clicked()), this, SLOT(dbmShowingSlot()));
	connect(m_SinrShowingButton, SIGNAL(clicked()), this, SLOT(sinrShowingSlot()));
	connect(m_selectComponentWidget, SIGNAL(currentIndexChanged(const QString&)),this, SLOT(switchComponentType(const QString&)));
	connect(m_applyHeightMapData, SIGNAL(clicked()), this, SLOT(writeHeightMapPointsDataSlot()));
	connect(m_contourShowingButton, SIGNAL(clicked()), this, SLOT(drawHeightMapContourSlot()));
	connect(m_runResetButton, SIGNAL(clicked()), this, SLOT(resetSceneSlot()));
	connect(m_runComponentsDetectionButton, SIGNAL(clicked()), this, SLOT(detectComponentsSlot()));
	//m_parametersWidget
}




 const wchar_t *  FloorPlanSegmentationGui::GetWC(const char *c)
{
	const size_t cSize = strlen(c) + 1;
	wchar_t* wc = new wchar_t[cSize];
	mbstowcs(wc, c, cSize);
	return wc;

}


 void  FloorPlanSegmentationGui::callPythonFunction(/*const std::vector<int>& imageSizes*/)
{
	PyObject *pName, *pModule, *pFunc;
	PyObject *pArgs, *pValue;
	int i;
	pArgs = NULL;
	std::cout << "Prepare for python call !!!!! \n";
	/*if (argc < 3) {
	fprintf(stderr, "Usage: call pythonfile funcname [args]\n");
	return 1;
	}*/

////	Py_Initialize();

////	pName = PyUnicode_FromString("MainRf_rayTracingCurrentState");
	
	/* Error checking of pName left out */
	//if (!m_isPythonModuleInitialized) {
		//m_pModule = new PyObject;
		
	////	m_pModule = PyImport_Import(pName);
	
//	}
	std::cout << "Prepare for python call111111111111111111111 !!!!! \n";
////	Py_DECREF(pName);
	//if (m_pModule == NULL) {
	//	std::cout << "Module is null \n";
	

		///Py_Initialize();
		Py_Initialize();
		//pName = PyUnicode_FromString("MainRf_rayTracingCurrentState");

	
		//if (!m_isPythonModuleInitialized) {
		//m_pModule = new PyObject;

	//	m_pModule = PyImport_Import(pName);
		m_pFunc = PyObject_GetAttrString(m_pModule, "finalFunctionHeightMap");

	//}
	if (m_pModule != NULL) {
		//if (!m_isPythonModuleInitialized) {
		    std::cout << "Before Pfunction \n";
		//	m_pFunc = PyObject_GetAttrString(m_pModule, "finalFunctionHeightMap");
			std::cout << "After PFunction \n";
		//	m_isPythonModuleInitialized = true;
	//	}
		/* pFunc is a new reference */

		if (m_pFunc && PyCallable_Check(m_pFunc)) {
			//pArgs = PyTuple_New(2);
			/*for (i = 0; i < imageSizes.size(); ++i) {
				//	pValue = PyInt_FromLong(atoi(argv[i + 3]));
				std::cout << "Inside for cycle \n";
				pValue = PyLong_FromLong(imageSizes[i]);

				if (!pValue) {
					Py_DECREF(pArgs);
					Py_DECREF(m_pModule);
					fprintf(stderr, "Cannot convert argument\n");
					return;
				
				PyTuple_SetItem(pArgs, i, pValue);
			}*/
			std::cout << "Python function calll final !!!!! \n";
			pValue = PyObject_CallObject(m_pFunc, pArgs);
			Py_DECREF(pArgs);
			if (pValue != NULL) {

				printf("Result of call: %ld\n", PyLong_AsLong(pValue));
				Py_DECREF(pValue);
			}
			else {
				Py_DECREF(m_pFunc);
				Py_DECREF(m_pModule);
				PyErr_Print();
				fprintf(stderr, "Call failed\n");
				return;
			}
		}
		else {
			if (PyErr_Occurred())
				PyErr_Print();
			//fprintf(stderr, "Cannot find function \"%s\"\n", argv[2]);
		}
		Py_XDECREF(m_pFunc);
		Py_DECREF(m_pModule);
	}
	else {
		PyErr_Print();
		//fprintf(stderr, "Failed to load \"%s\"\n", argv[1]);
		return;
	}
	Py_Finalize();
	return;

}


void FloorPlanSegmentationGui::mousePressEvent(QGraphicsSceneMouseEvent * e)
{


	std::cout << "PRESSSSSSSSSSSSSSSSSSSSS " << std::endl;
	double rad = 1;

	//std::cout << "XXXXXXXXXXXXXXXXXXXXX   " << e->pos().x()<<std::endl;
	//	QPointF pt = m_mainGraphicsView->mapFromParent(e->pos());
	//std::cout << "POint coors " << std::endl;
	//m_mainGraphicsScene->addEllipse(pt.x() - rad, pt.y() - rad, rad, rad,
	//QPen(), QBrush(Qt::SolidPattern));

}

void FloorPlanSegmentationGui::switchComponentType(const QString& compName)
{
	/*std::cout << "Value changed \n";
	if (compName.toStdString() != "HeightMap") {
		m_fs.release();
	}*/


	if (m_selectComponentWidget->currentText() != "HeightMap") {
		std::string imageSizeFileName = "imageSize.txt";
		std::ofstream fileSize;
		fileSize.open(imageSizeFileName);
		fileSize.close();
	}



	if (compName.toStdString() == "HeightMap") {
		std::cout << "Opened new file !!!!!!!!!!!! \n";
		std::string filename = "testHeightMapData.xml";
		cv::FileStorage fs(filename, cv::FileStorage::WRITE);
		fs.release();
		std::string filename1 = "testHeightMapDataAutoGenerated.xml";
		cv::FileStorage fs1(filename1, cv::FileStorage::WRITE);
		fs1.release();



		QList<QGraphicsItem*> all = m_mainGraphicsScene->items();

		std::cout << "After getting items " << all.size() << " \n";
		//m_mainGraphicsScene->clear();
		//if (all.size() > 0) {
		for (int i = 0; i < all.size(); i++)
		{
			QGraphicsItem *gi = all[i];
			m_mainGraphicsScene->removeItem(gi);
			//delete gi;
			m_mainGraphicsScene->update();
		}
		m_pixmapItem =  new QGraphicsPixmapItem();
		m_mainGraphicsScene->addItem(m_pixmapItem);
		m_pixmapItem->setPixmap(QPixmap::fromImage(m_image));
		m_pixmapItem->setPos(0, 0);

		m_pixmapItem = NULL;
		delete m_pixmapItem;

		m_poly.clear();
		for (int i = 0; i < m_elipseItemsVec.size(); ++i) {
			m_mainGraphicsScene->removeItem(m_elipseItemsVec[i]);

		}
		for (int i = 0; i < m_elipseItemsVec.size(); ++i) {
			//m_mainGraphicsScene->removeItem(m_elipseItemsVec[i]);
			delete m_elipseItemsVec[i];
		}
		m_elipseItemsVec.clear();

		qDebug() << "Dialog closed imid";

		m_countOfHeightMapPoints = 0;
		m_pointsVecForHeightMap.clear();
		std::cout << "Selected heightmap mode \n";
		m_applyHeightMapData->setEnabled(true);
		m_runHeightMapGenerationButton->setEnabled(false);
		m_isSelectedAxisPoint = false;
	}
	else {
		m_pixmapItem = new QGraphicsPixmapItem();
		m_mainGraphicsScene->addItem(m_pixmapItem);
		
		m_pixmapItem->setPixmap(QPixmap::fromImage(m_image));
		m_pixmapItem->setPos(0, 0);

		m_pixmapItem = NULL;
		delete m_pixmapItem;
	}




	
}



void FloorPlanSegmentationGui::writeHeightMapPointsDataSlot()
{
	std::cout << "HeightMap points count " << m_pointsVecForHeightMap.size() << std::endl;

	std::string filename = "testHeightMapData.xml";
	cv::FileStorage fs(filename, cv::FileStorage::APPEND);



	std::vector<std::vector<cv::Point>> myvector;
		for (int i = 0; i < 3; ++i) {
			std::vector<cv::Point> tmpVec;
			myvector.push_back(tmpVec);
		}
	
		cv::Point point11 = cv::Point(10, 20);
		cv::Point point12 = cv::Point(10, 50);
		myvector[0].push_back(point11);
		myvector[0].push_back(point12);
	
		cv::Point point21 = cv::Point(50, 50);
		cv::Point point22 = cv::Point(100, 50);
		myvector[1].push_back(point21);
		myvector[1].push_back(point22);
	
		cv::Point point31 = cv::Point(150, 150);
		cv::Point point32 = cv::Point(200, 200);
		myvector[2].push_back(point31);
		myvector[2].push_back(point32);
	
	
	
//		std::string filename = "testHeightMapData.xml";
	//	cv::FileStorage fs(filename, cv::FileStorage::WRITE);
		//fs << "data" << "{";
		for (int i = 0; i < m_pointsVecForHeightMap.size(); ++i)
		{
			//Write each vector
			std::string vectorName ="vector" + std::to_string((long)i) ;
			fs <<  vectorName<< "{";
			//fs << pointName << "{";
			//for (int j = 0; j < m_pointsVecForHeightMap[i].size(); ++j)
		//	{
				std::string pointNameX0 = "x" + std::to_string(0);
				std::string pointNameY0 = "y" + std::to_string(0);
				std::string pointNameX1 = "x" + std::to_string(1);
				std::string pointNameY1 = "y" + std::to_string(1);
				fs << pointNameX0 << m_pointsVecForHeightMap[i].first.x << pointNameY0 << m_pointsVecForHeightMap[i].first.y;
				if (i == m_pointsVecForHeightMap.size() - 1 && m_countOfHeightMapPoints % 2 == 1) {
					fs << pointNameX1 << m_pointsVecForHeightMap[i].first.x << pointNameY1 << m_pointsVecForHeightMap[i].first.y;
				}
				else {
					fs << pointNameX1 << m_pointsVecForHeightMap[i].second.x << pointNameY1 << m_pointsVecForHeightMap[i].second.y;
				}

				//fs << "}"; // close point
	//		}
			fs << "}"; // close vector
		}
		//fs << "}"; // close data
		fs.release();

		if (m_isSelectedAxisPoint == true && m_pointsVecForHeightMap.size() > 0 ) {
			m_runHeightMapGenerationButton->setEnabled(true);
		}
		m_pointsVecForHeightMap.clear();
		m_countOfHeightMapPoints = 0;
		
	
}


void FloorPlanSegmentationGui::drawHeightMapContourSlot()
{

	std::cout << "contour drawing slot !!!!!!!!!!!!!  \n";

	cv::Mat heightmapImage;
	heightmapImage = m_heightMapImage.clone();
	//QImage image;
	if (m_contourShowingButton->isChecked()) {
		heightmapImage = heightmapImage + m_contourImage.clone();
	} 
	QImage image(heightmapImage.data, heightmapImage.cols, heightmapImage.rows, QImage::Format_RGB888);




	//	QImage image(fileName);
	//image = image.scaled(image.width()/1.3,image.height()/1.3);
	/////	m_image = image;
	QList<QGraphicsItem*> all = m_mainGraphicsScene->items();

	std::cout << "After getting items " << all.size() << " \n";
	//m_mainGraphicsScene->clear();
	//if (all.size() > 0) {
	for (int i = 0; i < all.size(); i++)
	{
		QGraphicsItem *gi = all[i];
		m_mainGraphicsScene->removeItem(gi);
		//delete gi;
		m_mainGraphicsScene->update();
	}
	m_pixmapItem = new QGraphicsPixmapItem();
	m_mainGraphicsScene->addItem(m_pixmapItem);
	m_pixmapItem->setPixmap(QPixmap::fromImage(image));
	m_pixmapItem->setPos(0, 0);




}




void FloorPlanSegmentationGui::resetSceneSlot()
{

	
	//QImage image(heightmapImage.data, heightmapImage.cols, heightmapImage.rows, QImage::Format_RGB888);




	//	QImage image(fileName);
	//image = image.scaled(image.width()/1.3,image.height()/1.3);
	/////	m_image = image;


	std::string imageSizeFileName = "imageSize.txt";
	std::ofstream fileSize;
	fileSize.open(imageSizeFileName);
	fileSize.close();

	std::string filename = "testHeightMapData.xml";
	cv::FileStorage fs(filename, cv::FileStorage::WRITE);
	fs.release();



	QList<QGraphicsItem*> all = m_mainGraphicsScene->items();

	std::cout << "After getting items " << all.size() << " \n";
	//m_mainGraphicsScene->clear();
	//if (all.size() > 0) {
	for (int i = 0; i < all.size(); i++)
	{
		QGraphicsItem *gi = all[i];
		m_mainGraphicsScene->removeItem(gi);
		//delete gi;
		m_mainGraphicsScene->update();
	}
	m_pixmapItem = new QGraphicsPixmapItem();
	m_mainGraphicsScene->addItem(m_pixmapItem);
	m_pixmapItem->setPixmap(QPixmap::fromImage(m_image));
	m_pixmapItem->setPos(0, 0);
}



void FloorPlanSegmentationGui::detectComponentsSlot()
{
	std::vector<cv::Point> detectedPointsVec = m_componentDetector.getDetectedPoints();

	QBrush brush;
	brush.setColor(Qt::green);

	brush.setStyle(Qt::SolidPattern);
	QPen pen(Qt::green);
	pen.setBrush(brush);
	pen.setWidth(1);
	for (int i = 0; i < detectedPointsVec.size(); ++i) {
		QGraphicsEllipseItem* elipseItem = new QGraphicsEllipseItem;

		elipseItem->setPen(pen);
		elipseItem->setBrush(brush);
		elipseItem->setRect(detectedPointsVec[i].x, detectedPointsVec[i].y, 1, 1);
		m_mainGraphicsScene->addItem(elipseItem);


		elipseItem = NULL;
		delete elipseItem;

	//	m_elipseItemsVec.push_back(elipseItem);

	}


	std::string filename = "testHeightMapDataAutoGenerated.xml";
	cv::FileStorage fs(filename, cv::FileStorage::WRITE);



	for (int i = 0; i < detectedPointsVec.size(); ++i)
	{
		//Write each vector
		std::string vectorName = "vector" + std::to_string((long)i);
		fs << vectorName << "{";
		//fs << pointName << "{";
		//for (int j = 0; j < m_pointsVecForHeightMap[i].size(); ++j)
		//	{
		std::string pointNameX0 = "x" + std::to_string(0);
		std::string pointNameY0 = "y" + std::to_string(0);
		//std::string pointNameX1 = "x" + std::to_string(1);
		//std::string pointNameY1 = "y" + std::to_string(1);
		fs << pointNameX0 << detectedPointsVec[i].x << pointNameY0 << detectedPointsVec[i].y;
		

		//fs << "}"; // close point
		//		}
		fs << "}"; // close vector
	}
	//fs << "}"; // close data
	fs.release();






}

void FloorPlanSegmentationGui::setSelectedImagePath() {


	std::string imageSizeFileName = "imageSize.txt";
	std::ofstream fileSize;
	fileSize.open(imageSizeFileName);
	fileSize.close();

	std::string filename = "testHeightMapData.xml";
	cv::FileStorage fs(filename, cv::FileStorage::WRITE);
	fs.release();
	m_isSelectedAxisPoint = false;
	m_runHeightMapGenerationButton->setEnabled(false);

	QString fileName = QFileDialog::getOpenFileName(this,
		tr("Open Image"), "/home/jana", tr("Image Files (*.png *.jpg *.bmp)"));
	std::cout << "CLICKED !!!!" << std::endl;
	//QString filename = "E:/upworkProjs/FloorPlanAnalyzing/Venue_Images/TuckerStadium/1.png";
	QImage image(fileName);
	//image = image.scaled(image.width()/1.3,image.height()/1.3);
	m_image = image;



	QList<QGraphicsItem*> all = m_mainGraphicsScene->items();

	std::cout << "After getting items " << all.size() << " \n";
	//m_mainGraphicsScene->clear();
	//if (all.size() > 0) {
	for (int i = 0; i < all.size(); i++)
	{
		QGraphicsItem *gi = all[i];
		m_mainGraphicsScene->removeItem(gi);
		//delete gi;
		m_mainGraphicsScene->update();
	}
	m_pixmapItem = new QGraphicsPixmapItem();
	m_mainGraphicsScene->addItem(m_pixmapItem);
	m_pixmapItem->setPixmap(QPixmap::fromImage(m_image));
	m_pixmapItem->setPos(0, 0);

	
	m_poly.clear();
	for (int i = 0; i < m_elipseItemsVec.size(); ++i) {
		m_mainGraphicsScene->removeItem(m_elipseItemsVec[i]);

	}
	for (int i = 0; i < m_elipseItemsVec.size(); ++i) {
		//m_mainGraphicsScene->removeItem(m_elipseItemsVec[i]);
		delete m_elipseItemsVec[i];
	}
	m_elipseItemsVec.clear();






	//fileSize.open(imageSizeFileName);
	//fileSize << m_image.width() << " " << m_image.height() << " " << 10 << " " << 10;
	//fileSize.close();



	m_mainGraphicsScene->setSceneRect(0,0,image.width(), image.height());
//	m_mainGraphicsScene->clear();
	QImage temp = m_image.copy();


	
	std::cout << "     Initial depth state           " << temp.depth() << std::endl;;
	
	
	if (temp.depth() != 0) {
		if (temp.depth() == 8) {
			cv::Mat res(temp.height(), temp.width(), CV_8UC1, (uchar*)temp.bits(), temp.bytesPerLine());
			//cvtColor(res, res, CV_BGRA2BGR);
			m_cvImage = res.clone();
		}
		else if (temp.depth() == 32) {
			cv::Mat res(temp.height(), temp.width(), CV_8UC4, (uchar*)temp.bits(), temp.bytesPerLine());
			//cvtColor(res, res, CV_BGRA2BGR);
			m_cvImage = res.clone();

		}
		else if (temp.depth() == 24) {
			cv::Mat res(temp.height(), temp.width(), CV_8UC3, (uchar*)temp.bits(), temp.bytesPerLine());
			//cvtColor(res, res, CV_BGRA2BGR);
			m_cvImage = res.clone();

		}

	}
	/*else {
		return;
	}
	cv::imshow("CurrentImage", m_cvImage);
	cv::waitKey(0);*/

	//cv::Mat tmpImageContDet = QImageToCvMat(temp, true);
//	cvtColor(tmpImageContDet, tmpImageContDet, cv::COLOR_RGB2BGR);

	m_componentDetector = componentsDetector();
	m_componentDetector.setInputImage(fileName.toStdString());


	m_componentDetector.findInnerAndOuterWallPoints();
//	m_componentDetector.visualizeDetections();
	m_pixmapItem->setPixmap(QPixmap::fromImage(m_image));
	m_pixmapItem->setPos(0, 0);


	 all = m_mainGraphicsScene->items();
	
	std::cout << "After getting items " << all.size() << " \n";
	//m_mainGraphicsScene->clear();
	//if (all.size() > 0) {
		for (int i = 0; i < all.size(); i++)
		{
			QGraphicsItem *gi = all[i];
			m_mainGraphicsScene->removeItem(gi);
			delete gi;
			m_mainGraphicsScene->update();
		}
	//}
		
		QGraphicsPixmapItem*   m_pixmapItem =  new QGraphicsPixmapItem;//  new QGraphicsPixmapItem(/*QPixmap::fromImage(image)*/);
	
		m_pixmapItem->setPixmap(QPixmap::fromImage(m_image));
		m_pixmapItem->setPos(0, 0);
		m_mainGraphicsScene->addItem(m_pixmapItem);


		std::string filename1 = "testHeightMapDataAutoGenerated.xml";
		cv::FileStorage fs1(filename1, cv::FileStorage::WRITE);
		fs1.release();

	//	delete pixmapItemTmp;

	
		
}


void  FloorPlanSegmentationGui::runSegmentation() {

	int maximumContSize = 0;
	int indexOfBiggestCont = -1;
	cv::Mat canny_output;
	std::vector<std::vector<cv::Point> > contours;
	std::vector<std::vector<cv::Point> > filteredContours;
	std::vector<cv::Vec4i> hierarchy;
	

//	cv::imshow("InitImg", m_cvImage);
	//cv::waitKey(0);

	cv::Mat imgfordraw =  m_cvImage.clone();
	cv::Mat initialMat = m_cvImage.clone();
	std::cout << "Before crash " << std::endl;
	if (initialMat.channels() == 3) {
		cv::cvtColor(initialMat, initialMat, CV_BGR2GRAY);
	}
	
	std::cout << "After crash !!" << std::endl;

	

	cv::erode(initialMat, initialMat, cv::Mat());
		

	
	cv::Mat cannyImg;
	cv::Canny(initialMat, cannyImg, 150, 170);

	cv::findContours(cannyImg, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, cv::Point(0, 0));
	//std::cout << "contours sizwe " << contours.size() << std::endl;
	
	
	cv::Mat drawing = cv::Mat::zeros(initialMat.size(), CV_8UC3);
	
	for (int i = 0; i < contours.size(); ++i) {
			cv::Scalar color = cv::Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
			if (contours[i].size() > 10) {
				cv::drawContours(drawing, contours, i, color, 2, 8, hierarchy, 0, cv::Point());
			}
		}
	
	
	
		for (int i = 0; i< contours.size(); i++)       
		{
			//drawing = imgfordraw.clone(); 
			if (contours[i].size() > maximumContSize) {
				maximumContSize = contours[i].size();
				indexOfBiggestCont = i;
			}
			cv::Scalar color = cv::Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
			//if (contours[i][0] == contours[i][contours[i].size() - 1]) {
				//drawcontours(drawing, contours, i, color, 2, 8, hierarchy, 0, cv::point());
			//} 
		//	cv::waitkey(0);
		}



		;

	
		cv::Rect bigestrect = cv::boundingRect(contours[indexOfBiggestCont]);
		for (int j = 0; j < contours.size(); ++j) {
			cv::Rect tmprect = cv::boundingRect(contours[j]);
			if (    bigestrect.area() / tmprect.area() >= 1.  && bigestrect.area() / tmprect.area() < 100) {
				filteredContours.push_back(contours[j]);
				//cv::scalar color = cv::scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
				//drawcontours(drawing, contours, j, color, 2, 8, hierarchy, 0, cv::point());
			
			}
	
		}

		

	//	std::cout << "filtered contours size " << filteredContours.size() << std::endl;
		cv::Mat contMat = cv::Mat(imgfordraw.rows, imgfordraw.cols, CV_8UC3, cv::Scalar::all(0));


		

		for (int i = 0; i < filteredContours.size(); ++i) {
			cv::Scalar color = cv::Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
			drawContours(imgfordraw, filteredContours, i, color, 2, 8, hierarchy, 0, cv::Point());
			drawContours(contMat, filteredContours, i, color, 2, 8, hierarchy, 0, cv::Point());
		//	cv::pointpolygontest(filteredcontours[i],)
		//	cv::fillpoly(contmat, contours, cv::scalar(255, 255, 255));
		//	ispointinsidecontour(filteredcontours[i], contmat);
		//	std::cout << "current contour initiasl " << std::endl;
		
		}
	

		cv::imshow("drawinginit", contMat);
		cv::waitKey(0);

		for (int g = 0; g < filteredContours.size(); ++g) {
	
			//ispointinsidecontour(filteredcontours[g], contmat);
			//continue;
		//	std::cout << "current contour" << std::endl;
			cv::Rect tmprect = cv::boundingRect(filteredContours[g]);
			cv::Scalar color = cv::Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
		//	cv::scalar color = cv::scalar(0, 255, 0);
			for (int i = 0; i < imgfordraw.rows; ++i) {
				for (int j = 0; j < imgfordraw.cols; ++j) {
					//imgfordraw.at<cv::vec3b>(i, j) = cv::vec3b(255, 0, 0);
					
					if (  cv::pointPolygonTest(filteredContours[g],cv::Point2f(j,i),false)  /*tmprect.contains(cv::point2i(j,i))*//*cv::pointpolygontest(filteredcontours[g],cv::point2f(j,i),false) == 1 || cv::pointpolygontest(filteredcontours[g], cv::point2f(j, i), false) == 0*/) {
						contMat.at<cv::Vec3b>(i, j)[0] = color[0] ;
						contMat.at<cv::Vec3b>(i, j)[1] = color[1];
						contMat.at<cv::Vec3b>(i, j)[2] = color[2];
	
					}
					/*else if (cv::pointpolygontest(filteredcontours[g], cv::point2f(j, i), true) > -5) {
						contmat.at<cv::vec3b>(i, j)[0] = color[0];
						contmat.at<cv::vec3b>(i, j)[1] = color[1];
						contmat.at<cv::vec3b>(i, j)[2] = color[2];
					}*/
					
				//	cv::imshow("imgfordraw", imgfordraw);
				//	cv::waitkey(10);
					
				}
			}
			
		
		}
		//cv::imshow("drawinginit", contMat);
		//cv::waitKey(0);
		return;

	//	cv::namedWindow("contmatfinal");
		//cv::moveWindow("contmatfinal", 100, 100);
		//cv::imshow("contmatfinal", contMat);
		//cv::imwrite("e:/upworkprojs/floorplananalyzing/goodworkingexamples/2dfloorplansimpleres8.jpg",contmat);
		//cv::imshow("imgfordraw", imgfordraw);
		
		//cv::waitKey(0);
	//	drawcontours(drawing, contours, indexofbiggestcont, cv::scalar(0,255,0), 2, 8, hierarchy, 0, cv::point());
	
		for (int i = 0; i< contours.size(); i++)
		{
			if (contours[i].size() > maximumContSize) {
				maximumContSize = contours[i].size();
				indexOfBiggestCont = i;
			}
			if (i != maximumContSize) {
				cv::Scalar color = cv::Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
				cv::drawContours(drawing, contours, i, color, 2, 8, hierarchy, 0, cv::Point());
			}
		}


		QImage imgIn = QImage((uchar*)contMat.data, contMat.cols, contMat.rows, contMat.step, QImage::Format_RGB888);
		m_pixmapItem->setPixmap(QPixmap::fromImage(imgIn));
		m_pixmapItem->setPos(0, 0);
		


		
	//	cv::imshow("initimg", initialMat);		
		//cv::waitKey(0); 
	;
}


void FloorPlanSegmentationGui::runHeightMapGeneration()
{

	int retCode = system("HeightMapGeneration.exe ");
	if (retCode == 0) {
		return ;
	}
	cv::namedWindow("HeightMap1");
	cv::Mat heightmapImage = cv::imread("resultImageFull.png");

	QString fileName = "resultImageFull.png";
	

	QString fileName1 = "maskImgHeight.png";
	//QImage image1(fileName1);
	

	cv::Mat maskImg = cv::imread(fileName1.toStdString());
	cv::Mat resContourImage;
	findOuterContour(maskImg, resContourImage);

	cv::cvtColor(resContourImage, resContourImage, CV_BGR2RGB);
	QImage imageContour(resContourImage.data, resContourImage.cols, resContourImage.rows, QImage::Format_RGB888);

	

	cv::cvtColor(heightmapImage, heightmapImage, CV_BGR2RGB);
	m_heightMapImage = heightmapImage.clone();
	m_contourImage = resContourImage.clone();


	if (m_contourShowingButton->isChecked()) {
		heightmapImage = heightmapImage + resContourImage;
	}

	QImage image(heightmapImage.data, heightmapImage.cols, heightmapImage.rows, QImage::Format_RGB888);

   QImage imageTr(heightmapImage.data, heightmapImage.cols, heightmapImage.rows, QImage::Format_RGBA8888);
   QImage imageTr1 = QImage(heightmapImage.cols, heightmapImage.rows, QImage::Format_RGBA8888);

 


   for (int i = 0; i < imageTr1.height(); ++i) {
	   for (int j = 0; j < imageTr1.width(); ++j) {
		  // QRgb apixel = image.pixel(j, i);
		   //imageTr.setPixel(j, i,
			  // qRgba(image.pixel(j,i

		   imageTr1.setPixel(j, i,
			   qRgba(heightmapImage.at<cv::Vec3b>(i,j)[0],
				   heightmapImage.at<cv::Vec3b>(i, j)[1],
				   heightmapImage.at<cv::Vec3b>(i, j)[2],
				   230));
				//   qRgba valueTmp1 = QRgba(apixel.red(), apixel.green(), apixel.blue(), 200);
		   
		  // p2.setPixel(i, j, value);
	   }
	}

	
    
//	QImage image(fileName);
	//image = image.scaled(image.width()/1.3,image.height()/1.3);
/////	m_image = image;
	QList<QGraphicsItem*> all = m_mainGraphicsScene->items();

	std::cout << "After getting items " << all.size() << " \n";
	//m_mainGraphicsScene->clear();
	//if (all.size() > 0) {
	for (int i = 0; i < all.size(); i++)
	{
		QGraphicsItem *gi = all[i];
		m_mainGraphicsScene->removeItem(gi);
		//delete gi;
		m_mainGraphicsScene->update();
	}



	m_pixmapItem = new QGraphicsPixmapItem();
	m_mainGraphicsScene->addItem(m_pixmapItem);
	m_pixmapItem->setPixmap(QPixmap::fromImage(m_image));
	m_pixmapItem->setPos(0, 0);

	m_pixmapItem = NULL;
	delete m_pixmapItem;

	m_pixmapItem = new QGraphicsPixmapItem();
	m_mainGraphicsScene->addItem(m_pixmapItem);
	m_pixmapItem->setPixmap(QPixmap::fromImage(imageTr1));
//	m_mainGraphicsScene->addItem(m_pixmapItem);
	m_pixmapItem->setPos(0, 0);
	
	m_pixmapItem = NULL;
	delete m_pixmapItem;

	cv::Mat resHeightMapImage;
	cv::Mat resSinrMapImage;
	parseHeightMapTxtFile(resHeightMapImage, resSinrMapImage);



/*	QList<QGraphicsItem*> all = m_mainGraphicsScene->items();

	std::cout << "After getting items " << all.size() << " \n";


	QImage image("testfileRes.png");
	//image = image.scaled(image.width()/1.3,image.height()/1.3);
	
	m_mainGraphicsScene->setSceneRect(0, 0, image.width(), image.height());
	m_pixmapItem = new QGraphicsPixmapItem();
	m_mainGraphicsScene->addItem(m_pixmapItem);
	m_pixmapItem->setPixmap(QPixmap::fromImage(image));
	m_pixmapItem->setPos(0, 0);

*/













	/*std::cout << "Called heihjt map generation \n";
	std::vector<int> imageSizeVec;
	imageSizeVec.push_back(m_image.width());
	imageSizeVec.push_back(m_image.height());*/
//	callPythonFunction(/*imageSizeVec*/);
		//PyObject *pName, *pModule, *pFunc;
		//PyObject *pArgs, *pValue;
		//int i;
	
	
		///*if (argc < 3) {
		//	fprintf(stderr, "Usage: call pythonfile funcname [args]\n");
		//	return 1;
		//}*/
	
		//Py_Initialize();
		//
		//pName = PyUnicode_FromString( "MainRf_rayTracingCurrentState");
		//
		///* Error checking of pName left out */
	
		//pModule = PyImport_Import(pName);
		//Py_DECREF(pName);
	
		//if (pModule != NULL) {
		//	pFunc = PyObject_GetAttrString(pModule, "finalFunctionHeightMap");
		//	/* pFunc is a new reference */
	
		//	if (pFunc && PyCallable_Check(pFunc)) {
		//		//pArgs = PyTuple_New(argc - 3);
		//		//for (i = 0; i < argc - 3; ++i) {
		//		////	pValue = PyInt_FromLong(atoi(argv[i + 3]));
		//		//	pValue =   PyLong_FromLong(atol(argv[i + 3]));
		//		//	
		//		//	if (!pValue) {
		//		//		Py_DECREF(pArgs);
		//		//		Py_DECREF(pModule);
		//		//		fprintf(stderr, "Cannot convert argument\n");
		//		//		return 1;
		//		//	}
		//		//	/* pValue reference stolen here: */
		//		//	PyTuple_SetItem(pArgs, i, pValue);
		//		//}
		//		std::cout << "Before calling function \n";
		//		//printf(pFunc.c);
		//		pValue = PyObject_CallObject(pFunc, pArgs);
		//		std::cout << "After calling functio n  \n";
		//		Py_DECREF(pArgs);
		//		if (pValue != NULL) {
		//			
		//			printf("Result of call: %ld\n", PyLong_AsLong(pValue));
		//			Py_DECREF(pValue);
		//		}
		//		else {
		//			Py_DECREF(pFunc);
		//			Py_DECREF(pModule);
		//			PyErr_Print();
		//			fprintf(stderr, "Call failed\n");
		//			return ;
		//		}
		//	}
		//	else {
		//		if (PyErr_Occurred())
		//			PyErr_Print();
		//		//fprintf(stderr, "Cannot find function \"%s\"\n", argv[2]);
		//	}
		//	Py_XDECREF(pFunc);
		//	Py_DECREF(pModule);
		//}
		//else {
		//	PyErr_Print();
		//	//fprintf(stderr, "Failed to load \"%s\"\n", argv[1]);
		//	return ;
		//}
		//Py_Finalize();	
}
 


void FloorPlanSegmentationGui::getSelectedPoints()
{

	QGraphicsLineItem* tmpLineitem = new QGraphicsLineItem;
	QGraphicsEllipseItem* elipseItem = new QGraphicsEllipseItem;
	std::cout << "GET SELECTED POINTS  " << std::endl;
	QPoint selectedPoint = m_mainGraphicsScene->transferPickedPointsPosition();
	std::cout << "Select points " << selectedPoint.x() << "   " << selectedPoint.y() << std::endl;


	QBrush brush;
	brush.setColor(Qt::red);
	brush.setStyle(Qt::SolidPattern);

	QPen pen(Qt::green);


	QPainter qPainter(&m_image);
	qPainter.setBrush(brush);
	qPainter.setPen(Qt::red);
	//qPainter.drawRect(selectedPoint.x(), selectedPoint.y(), 150, 150);
	//qPainter.drawEllipse(selectedPoint, 20, 20);


	//m_pixmapItem->setPixmap(QPixmap::fromImage(m_image));
	//m_pixmapItem->setPos(0, 0);


	QImage temp = m_image.copy();

//	if ( temp.hasAlphaChannel()){
//	cv::Mat res(temp.height(), temp.width(), CV_8UC3, (uchar*)temp.bits(), temp.bytesPerLine());


	//cv::circle(res, cv::Point(selectedPoint.x(), selectedPoint.y()), 20, cv::Scalar(0, 255, 0), 5);
	//cvtColor(res, res, CV_BGRA2BGR); // make convert colort to BGR ! 
									 //cv::imshow("Initimg", res);
									 //cv::waitKey(0);


	cv::Point tmpSelectedPoint = cv::Point(selectedPoint.x(), selectedPoint.y());





	if (  m_selectComponentWidget->currentText() == "HeightMap" &&  m_countOfHeightMapPoints % 2 == 0) {
		std::pair<cv::Point, cv::Point> tmpHeightSelPoint;
		tmpHeightSelPoint.first = tmpSelectedPoint;
		m_pointsVecForHeightMap.push_back(tmpHeightSelPoint);
		++m_countOfHeightMapPoints;
		std::cout << "Added one time " << m_countOfHeightMapPoints << std::endl;
	 
		
	}
	else if (m_selectComponentWidget->currentText() == "HeightMap" &&  m_countOfHeightMapPoints % 2 != 0)  {
		++m_countOfHeightMapPoints;
		std::cout << "Added second point " << m_countOfHeightMapPoints << std::endl;
		m_pointsVecForHeightMap[m_pointsVecForHeightMap.size() - 1].second = tmpSelectedPoint;

		QBrush brush;
		brush.setColor(Qt::green);

		brush.setStyle(Qt::SolidPattern);
		QPen pen(Qt::green);
		pen.setBrush(brush);
		pen.setWidth(5);
		
		//QLineF tmpLine;

	/////	QGraphicsLineItem* tmpLineitem = new QGraphicsLineItem;
		QLineF tmpLine;
		tmpLine.setLine(m_pointsVecForHeightMap[m_pointsVecForHeightMap.size() - 1].first.x, m_pointsVecForHeightMap[m_pointsVecForHeightMap.size() - 1].first.y, 
				m_pointsVecForHeightMap[m_pointsVecForHeightMap.size() - 1].second.x, m_pointsVecForHeightMap[m_pointsVecForHeightMap.size() - 1].second.y);
		tmpLineitem->setLine(tmpLine);
		tmpLineitem->setPen(pen);
		m_mainGraphicsScene->addItem(tmpLineitem);
	
	}
	//m_mainGraphicsScene->clear();
	//m_mainGraphicsScene->addEllipse(tmpSelectedPoint.x, tmpSelectedPoint.y, 10, 10, pen, brush);
	
//	elipseItem->setPos(tmpSelectedPoint.x, tmpSelectedPoint.y);
	elipseItem->setPen(pen);
	elipseItem->setBrush(brush);
	elipseItem->setRect(tmpSelectedPoint.x, tmpSelectedPoint.y, 10, 10);
	m_mainGraphicsScene->addItem(elipseItem);
	m_elipseItemsVec.push_back(elipseItem);
	//	m_mainGraphicsScene->addEllipse(100, 100, 10, 10, pen, brush);
//if (m_poly.size() == 0 && m_indexOfPolygonPoint > 0) {
		m_poly << QPointF(tmpSelectedPoint.x, tmpSelectedPoint.y);
	//}
      
	++m_indexOfPolygonPoint;

	
	//	detectAxisPoints(res, tmpSelectedPoint);

	elipseItem = NULL;
	delete elipseItem;

	tmpLineitem = NULL;
	delete tmpLineitem;


}

void FloorPlanSegmentationGui::drawPolygonFromSelectedPoints()
{
   
	QBrush brush;
	brush.setColor(Qt::red);
	brush.setStyle(Qt::SolidPattern);

	QPen pen(Qt::green);

//	m_mainGraphicsScene->addPolygon(m_poly, pen, brush);
	//setScene(graphics_scene_);
	//m_poly.clear();
//	m_tableWidget->show();
	//coloringOfSelectedPolygonSlot();

	QPushButton* button = m_parametersWidget->findChild<QPushButton*>("Apply");
//	qDebug() << "COMPBOXOBOX TEST  " << m_roomTypeComboBoBox->currentText();
	int compRes  = QString::compare("Room", m_selectComponentWidget->currentText(), Qt::CaseInsensitive);
	int compResHeightMap = QString::compare("HeightMap", m_selectComponentWidget->currentText(), Qt::CaseInsensitive);
	if (m_parametersWidget->exec() == QDialog::Accepted)
	{
		if (m_selectComponentWidget->currentText() == "Geojson") {
			//m_rotationAngle = std::atof(m_rotationAngleSpinBox->text().toStdString().c_str());
			m_scaleValueX = std::atof(m_scaleValueSpinBoxX->text().toStdString().c_str());
			m_scaleValueY = std::atof(m_scaleValueSpinBoxY->text().toStdString().c_str());
			std::cout << "Selected wall points count WALLLLLLL " << m_poly.size() << std::endl;





			std::stringstream out;

			out << std::fixed << std::setprecision(10) << std::stof(m_longtitudeSpinBox1->text().toStdString());

			m_longtitudeValue1 = std::stof(out.str());
			std::cout << "Longtitgude 1 " << std::setprecision(10) << m_longtitudeValue1 << std::endl;

			std::stringstream out1;
			out1 << std::fixed << std::setprecision(10) << std::stof(m_latitudeSpinBox1->text().toStdString());

			m_latitudeValue1 = std::stof(out1.str());

			std::cout << "Latitude 1 " << std::setprecision(10) << m_latitudeValue1 << std::endl;

			std::stringstream out2;

			out2 << std::fixed << std::setprecision(10) << std::stof(m_longtitudeSpinBox2->text().toStdString());

			m_longtitudeValue2 = std::stof(out2.str());



			std::cout << "Longtitgude 2 " << std::setprecision(10) << m_longtitudeValue2 << std::endl;


			std::stringstream out3;
			out3 << std::fixed << std::setprecision(10) << std::stof(m_latitudeSpinBox2->text().toStdString());

			m_latitudeValue2 = std::stof(out3.str());

			std::cout << "Latitude 2 " << std::setprecision(10) << m_latitudeValue2 << std::endl;



			float rotationAngle;
			float distanceBwetweenPoints;
			findRotationAngleAndDistance(m_latitudeValue1, m_longtitudeValue1, m_latitudeValue2, m_longtitudeValue2, rotationAngle, distanceBwetweenPoints);
			m_rotationAngle =  rotationAngle;

		//	findRotationAngleAndDistance()

			rotateCurrentImage();
		}
		if (!compRes ) {
			std::cout << "Selected rooom !!!!!!!!!!!!!" << std::endl;
		
			coloringOfSelectedPolygonSlot();
		} 
		else if (m_selectComponentWidget->currentText() == "Wall"){
			std::cout << "COunt of wall points " << m_poly.size() << std::endl;
			coloringOfSelectedWalls();
			generateGeojsonFileLast();
			//rotateCurrentImage();
		}
		qDebug() << "Apply button pressed!!";



		std::stringstream out;
		
		out << std::fixed << std::setprecision(10) << std::stof(m_longtitudeSpinBox1->text().toStdString());

		m_longtitudeValue1 = std::stof(out.str());
		
		std::stringstream out1;
		out1 << std::fixed << std::setprecision(10) << std::stof(m_latitudeSpinBox1->text().toStdString());

		m_latitudeValue1 = std::stof(out1.str());
		


		std::stringstream out2;

		out2 << std::fixed << std::setprecision(10) << std::stof(m_longtitudeSpinBox2->text().toStdString());

		m_longtitudeValue2 = std::stof(out2.str());

		std::stringstream out3;
		out3 << std::fixed << std::setprecision(10) << std::stof(m_latitudeSpinBox2->text().toStdString());

		m_latitudeValue2 = std::stof(out3.str());



		std::cout << "After parsing \n";


		std::cout << "LOTITUDE VALUE1 !!!!!!!!!   " << m_longtitudeValue1<< std::endl;
		std::cout << "LATITUDE VALUE1 !!!    " << m_latitudeValue1 << std::endl;

		std::cout << "LOTITUDE VALUE2 !!!!!!!!!   " << m_longtitudeValue2 << std::endl;
		std::cout << "LATITUDE VALUE2 !!!    " << m_latitudeValue2 << std::endl;


		m_poly.clear();

		for (int j = 0; j < m_elipseItemsVec.size(); ++j) {
			m_elipseItemsVecMain.push_back(QPointF(m_elipseItemsVec[j]->x(), m_elipseItemsVec[j]->y()));

		}

		for (int i = 0; i < m_elipseItemsVec.size(); ++i) {
			m_mainGraphicsScene->removeItem(m_elipseItemsVec[i]);
			

		}
		for (int i = 0; i < m_elipseItemsVec.size(); ++i) {
			//m_mainGraphicsScene->removeItem(m_elipseItemsVec[i]);
			delete m_elipseItemsVec[i];
		}
		m_elipseItemsVec.clear();



	}
	else
	{
	
		m_poly.clear();
		for (int i = 0; i < m_elipseItemsVec.size(); ++i) {
			m_mainGraphicsScene->removeItem(m_elipseItemsVec[i]);
		
		}
		for (int i = 0; i < m_elipseItemsVec.size(); ++i) {
			//m_mainGraphicsScene->removeItem(m_elipseItemsVec[i]);
			delete m_elipseItemsVec[i];
		}
		m_elipseItemsVec.clear();
		
		qDebug() << "Dialog closed imid";
	}
	//coloringOfSelectedPolygonSlot();
	//m_segmentDataWidget->show();
//	m_tableWidget->show();	
	//setCentralWidget(m_tableWidget);
	
}



bool FloorPlanSegmentationGui::parseHeightMapTxtFile(cv::Mat& resHeightMap, cv::Mat& resSINRMap)
{
	int number_of_lines = 0;
	int countOfColums = 0;
	std::string line;
	std::ifstream myfile("rfMapFull.txt");
	std::ifstream myfileSINR("sinrData.txt");

	std::vector<std::vector<int>> heighMapFileData;
	bool countOfColumscalculated = false;
	while (std::getline(myfile, line)) {
		std::vector<int> tmpLineData;
		++number_of_lines;
		std::vector<std::string> tokens;
		//if (!countOfColumscalculated) {
			//countOfColumscalculated = true;
		countOfColums = 0;
		std::string buf;                 // Have a buffer string
		std::stringstream ss(line);       // Insert the string into a stream

		//std::vector<std::string> tokens; // Create vector to hold our words

		while (ss >> buf)
			tmpLineData.push_back(std::atoi(buf.c_str()));
		if (!countOfColumscalculated) {
			countOfColums = tmpLineData.size();
		}
		else {
			if (countOfColums != tmpLineData.size()) {
				return false;
			}
		}
		heighMapFileData.push_back(tmpLineData);
				
	}
	resHeightMap = cv::Mat(number_of_lines, countOfColums, CV_32SC1);
	for (int i = 0; i < heighMapFileData.size(); ++i) {
		for (int j = 0; j < heighMapFileData[i].size(); ++j) {
			resHeightMap.at<int>(i, j) = heighMapFileData[i][j];
		}
	}
	number_of_lines = 0;
	countOfColums = 0;
   
	std::vector<std::vector<float>> sinrFileData;
	countOfColumscalculated = false;
	while (std::getline(myfileSINR, line)) {
		std::vector<float> tmpLineData;
		++number_of_lines;
		std::vector<std::string> tokens;
		//if (!countOfColumscalculated) {
		//countOfColumscalculated = true;
		countOfColums = 0;
		std::string buf;                 // Have a buffer string
		std::stringstream ss(line);       // Insert the string into a stream

										  //std::vector<std::string> tokens; // Create vector to hold our words

		while (ss >> buf)
			tmpLineData.push_back(std::atoi(buf.c_str()));
		if (!countOfColumscalculated) {
			countOfColums = tmpLineData.size();
		}
		else {
			if (countOfColums != tmpLineData.size()) {
				return false;
			}
		}
		sinrFileData.push_back(tmpLineData);

	}

	
	resSINRMap = cv::Mat(number_of_lines, countOfColums, CV_32FC1);
	if (resSINRMap.cols != resHeightMap.cols || resSINRMap.rows != resHeightMap.rows) {
		return false;
	}
	for (int i = 0; i < sinrFileData.size(); ++i) {
		for (int j = 0; j < sinrFileData[i].size(); ++j) {
			resSINRMap.at<float>(i, j) = sinrFileData[i][j];
		}
	}

	m_heightMapInitImage = resHeightMap.clone();
	m_sinrInitImage = resSINRMap.clone();
	return true;

//	std::cout << "Number of lines in text file: " << number_of_lines<<"\n";
	//std::cout << "Count of colums " << tokens.size() << "\n";
}



void FloorPlanSegmentationGui::findOuterContour(const cv::Mat& inputMaskImg, cv::Mat& resImg)
{
	cv::Mat grayImg;
	cv::cvtColor(inputMaskImg, grayImg, CV_BGR2GRAY);
	

	std::vector<std::vector<cv::Point> > contours;
	std::vector<cv::Vec4i> hierarchy;

	/// Detect edges using canny
//cv::Canny(grayImg, canny_output, 100, 150, 3);

	/// Find contours
	findContours(grayImg, contours, hierarchy, CV_RETR_TREE, CV_CHAIN_APPROX_SIMPLE, cv::Point(0, 0));
	cv::Mat drawing = cv::Mat::zeros(grayImg.size(), CV_8UC3);
	for (int i = 0; i< contours.size(); i++)
	{
		//cv::Scalar color = cv::Scalar(rng.uniform(0, 255), rng.uniform(0, 255), rng.uniform(0, 255));
		cv::Scalar color = cv::Scalar(0, 255, 0);
		drawContours(drawing, contours, i, color, 2, 8, hierarchy, 0, cv::Point());
	}
	resImg = drawing.clone();
//	cv::imshow("DrawingImag", drawing);
//	cv::waitKey(0);


}



void FloorPlanSegmentationGui::rotateCurrentImage()
{
	std::cout << "ROtating image \n";
	std::cout << "Selected image size " << m_image.height() << "    " << m_image.width() << std::endl;
	cv::Mat  currentMat = QImageToCvMat(m_image,true);
//	cv::imshow("Currentimage", currentMat);


	
	double angle = m_rotationAngle;
	/*if (m_rotationAngle > 0 ) {
		angle = 90 - m_rotationAngle;
	}
	else {
		angle = -(m_rotationAngle);
	}*/
	std::cout << "Rotation angle " << angle << std::endl;
	// get rotation matrix for rotating the image around its center in pixel coordinates
	cv::Point2f center((currentMat.cols - 1) / 2.0, (currentMat.rows - 1) / 2.0);
	cv::Mat rot = cv::getRotationMatrix2D(center, angle, 1.0);
	// determine bounding rectangle, center not relevant
	cv::Rect2f bbox = cv::RotatedRect(cv::Point2f(), currentMat.size(), angle).boundingRect2f();
	// adjust transformation matrix
	rot.at<double>(0, 2) += bbox.width / 2.0 - currentMat.cols / 2.0;
	rot.at<double>(1, 2) += bbox.height / 2.0 - currentMat.rows / 2.0;

	cv::Mat dst;
	cv::warpAffine(currentMat, dst, rot, bbox.size());

	cv::imwrite("rotatedImage.png", dst);

	
	cv::Mat temp = dst.clone(); // make the same cv::Mat
	//	if ( dst.channels() )
		//cvtColor(dst, temp, CV_BGR2RGB); // cvtColor Makes a copt, that what i need
	std::cout << "Channels copunt !!!!" << temp.channels() << std::endl;

	if (temp.channels() == 1) {
		cv::cvtColor(temp, temp, CV_GRAY2BGR);
	}
	else if ( temp.channels() == 4) {
		cv::cvtColor(temp, temp, CV_BGRA2BGR);

	}
	//	QImage dest((const uchar *)temp.data, temp.cols, temp.rows, temp.step, QImage::Format_Indexed8);
	//	dest.bits();
	//	m_image = dest;
	//}
	//else {
		QImage dest((const uchar *)temp.data, temp.cols, temp.rows, temp.step, QImage::Format_RGB888);
		dest.bits();
		m_image = dest;
//	}
	 // enforce deep copy, see documentation 
					 // of QImage::QImage ( const uchar * data, int width, int height, Format format )



	QList<QGraphicsItem*> all = m_mainGraphicsScene->items();

	std::cout << "After getting items " << all.size() << " \n";
	//m_mainGraphicsScene->clear();
	//if (all.size() > 0) {
	for (int i = 0; i < all.size(); i++)
	{
		QGraphicsItem *gi = all[i];
		m_mainGraphicsScene->removeItem(gi);
		//delete gi;
		m_mainGraphicsScene->update();
	}
	m_pixmapItem = new QGraphicsPixmapItem();
	m_mainGraphicsScene->addItem(m_pixmapItem);
	m_pixmapItem->setPixmap(QPixmap::fromImage(m_image));
	m_pixmapItem->setPos(0, 0);


	m_poly.clear();
	for (int i = 0; i < m_elipseItemsVec.size(); ++i) {
		m_mainGraphicsScene->removeItem(m_elipseItemsVec[i]);

	}
	for (int i = 0; i < m_elipseItemsVec.size(); ++i) {
		//m_mainGraphicsScene->removeItem(m_elipseItemsVec[i]);
		delete m_elipseItemsVec[i];
	}
	m_elipseItemsVec.clear();
	
	m_mainGraphicsScene->setSceneRect(0, 0, m_image.width(), m_image.height());

	std::cout << "Finishing rotation function " << std::endl;
}




float  FloorPlanSegmentationGui::getAngleBetweenPoints(const float& x1,const float&  y1, const float& x2,const float& y2)
{


	return std::atan2(y1 - y2, x2 - x1) * (180.0 / PI);

}


void FloorPlanSegmentationGui::findRotationAngleAndDistance(const float& latitude1, const float& longtitude1, const float& latitude2, const float& longtitude2, float& rotaionAngle, float& finalDist)
{

	float longtitudeDiff = longtitude2 - longtitude1;
	float latitudeDiff = latitude2 - latitude1;


	float sinLong1 = std::sin(longtitudeDiff*PI / 180);
	float cosLat1 = std::cos(latitude2*PI / 180);
	//	std::cout << "SINLOg1 "<<std::setprecision(10) << sinLong1 << std::endl;
	//	std::cout << "cosLat1 " << std::setprecision(10) << cosLat1 << std::endl;
	float X = sinLong1 * cosLat1;
	std::cout << std::setprecision(10) << "X is equal to " << X << std::endl;


	float Y = (std::cos(latitude1*PI / 180) * std::sin(latitude2*PI / 180)) -
		(std::sin(latitude1*PI / 180) * std::cos(latitude2*PI / 180) * std::cos(longtitudeDiff*PI / 180));

	//Rotation angle between geo points and Y axis
	rotaionAngle = std::atan2(X, Y) * radiantoDeg;

	//Rotation angle between geo points and X axis
	rotaionAngle = 90 - rotaionAngle;
	

	//float point1 =   m_poly[0].x();//
	float rotationAngleBetweenPoint  = 0;
	if (m_poly.size() >= 2) {
		rotationAngleBetweenPoint = getAngleBetweenPoints((float)(m_poly[0].x()), (float)(m_poly[0].y()), (float)(m_poly[1].x()), (float)(m_poly[1].y()));
	}
	//Rotation angle for applying on floor plan
	rotaionAngle = rotaionAngle - rotationAngleBetweenPoint;

	std::cout << std::setprecision(10) << " Y is equal to  " << Y << std::endl;
	std::cout << "Rotation angle!!!!!!!!!!!!!!!   " << rotaionAngle << std::endl;
 
	std::cout << std::setprecision(10) << " Y is equal to  " << Y << std::endl;
	std::cout << "Rotation angle   for points  !!!!!!!!!!!!!!!   " << rotationAngleBetweenPoint << std::endl;


	float distTmp1 = std::sin(latitudeDiff / 2 * PI / 180)  * std::sin(latitudeDiff / 2 * PI / 180) +
	std::cos(latitude1 * PI / 180) * std::cos(latitude2 * PI / 180) *  std::sin(longtitudeDiff  * PI / 180 / 2)
		* std::sin(longtitudeDiff * PI / 180 / 2);


	float distTmp2 = 2 * std::atan2(std::sqrt(distTmp1), std::sqrt(1- distTmp1));
	float radiusOfEarth = 6371000;
	finalDist = radiusOfEarth * distTmp2;

}

void FloorPlanSegmentationGui::generateGeojsonFileLast()
{



	std::string line1 = "{";
	std::string line2 = "\"type\": \"FeatureCollection\",";
	std::string line3 = "\"features\": [";
	std::string line4 = "{ \"type\": \"Feature\", \"properties\" : { \"OBJECTID\": 1, \"SHAPE_Length\" : 0.00 }, \"geometry\" : { \"type\": \"MultiPolygon\", \"coordinates\" : [[[";







	float initialLongttitude = std::atof(m_longtitudeSpinBox1->text().toStdString().c_str());
	float initialLatitude = std::atof(m_latitudeSpinBox1->text().toStdString().c_str());



	float secondLongttitude = std::atof(m_longtitudeSpinBox2->text().toStdString().c_str());
	float secondLatitude = std::atof(m_latitudeSpinBox2->text().toStdString().c_str());

	float rotationAngle;
	float realDistance;
	findRotationAngleAndDistance(initialLatitude, initialLongttitude, secondLatitude, secondLongttitude, rotationAngle, realDistance);



	std::string line5 = "[" + std::to_string(initialLongttitude) + ", " + std::to_string(initialLatitude) + "],";
	//	std::string line6 = "[-73.98197743701935, 40.7682282835967]";
	std::string line7 = "] ] ] } }]}";





	std::ofstream myfile;
	myfile.open("example.geojson");
	myfile << line1 << "\n";
	myfile << line2 << "\n";
	myfile << line3 << "\n";
	myfile << line4 << "\n";
	myfile << line5 << "\n";

	if (m_poly.size() < 2) {
		myfile << line7 << "\n";
		myfile.close();
		return;
	}
	float euqlideanDist = std::sqrt((m_poly[0].x() - m_poly[1].x())*(m_poly[0].x() - m_poly[1].x()) +
		(m_poly[0].y() - m_poly[1].y())*(m_poly[0].y() - m_poly[1].y()));
	float scalePerOneMeter = euqlideanDist / realDistance;
	//std::cout << "Euqlidean distance  " << euqlideanDist << std::endl;

	//	float initialLongttitude = -73.98397743701935;
	//	float initialLatitude = 40.7682282835967;
	for (int i = 1; i < m_poly.size(); ++i) {
		int currentX = m_poly[i].x();
		int currentY = m_poly[i].y();

		float earhRadius = 6378137;



		int distX = currentX - m_poly[0].x();
		int distY = -(currentY - m_poly[0].y());

	//	int distX = currentX - m_poly[i - 1].x();
	//	int distY = -(currentY - m_poly[i - 1].y());
		std::cout << "disttance X " << distX << std::endl;
		std::cout << "distance Y " << distY << std::endl;
		//float scalePerOneMeter = (float) 1.0 / (float) 111111.0;
		//std::cout << std::setprecision(10);
		std::cout << "scalePerMeter " << scalePerOneMeter << std::endl;
		std::cout << "Scale Value from GUI " << m_scaleValueX << std::endl;



		//	dLat = dn / R
		//		dLon = de / (R*Cos(Pi*lat / 180))
		





		float newLong;// = initialLongttitude + longtitudeX;
		float newLat;// = initialLatitude + lantitudeY;

		float distXMeter = (float)distX / (float)scalePerOneMeter;
		float distYMeter = (float)distY / (float)scalePerOneMeter;
		calculateLatAndLong(initialLatitude, initialLongttitude,distXMeter, distYMeter, newLat, newLong);
		std::cout << std::setprecision(10);
		std::cout << "PRINT Longtitude " << newLong << std::endl;
		std::cout << std::setprecision(10);
		std::cout << "Print Latitude  " << newLat << std::endl;

		std::string tmpLine = "[" + std::to_string(newLong) + "," + " " + std::to_string(newLat) + "]";
		if (i != m_poly.size() - 1) {
			tmpLine = tmpLine + ",";
		}
		std::cout << "Final line before writng into filee " << tmpLine << std::endl;
		myfile << tmpLine << "\n";
	////	initialLongttitude = newLong;
	////	initialLatitude = newLat;



	}



	//myfile << line6 << "\n";
	myfile << line7 << "\n";
	myfile.close();

}

void FloorPlanSegmentationGui::generateGeojsonFile()
{
/*
//	-73.98397743701935,
//		40.7682282835967


		//	"type": "FeatureCollection",
		//	"features" : [
	//	{ "type": "Feature", "properties" : { "OBJECTID": 1, "SHAPE_Length" : 0.00 }, "geometry" : { "type": "MultiPolygon", "coordinates" : [[[

	std::string line1 = "{";
	std::string line2 = "\"type\": \"FeatureCollection\",";
	std::string line3 = "\"features\": [";
	std::string line4 = "{ \"type\": \"Feature\", \"properties\" : { \"OBJECTID\": 1, \"SHAPE_Length\" : 0.00 }, \"geometry\" : { \"type\": \"MultiPolygon\", \"coordinates\" : [[[";
	






	float initialLongttitude = std::atof(m_longtitudeSpinBox->text().toStdString().c_str());
	float initialLatitude = std::atof(m_latitudeSpinBox->text().toStdString().c_str());




	std::string line5 = "[" + std::to_string(initialLongttitude)  +  ", "  + std::to_string(initialLatitude) + "],";
	//	std::string line6 = "[-73.98197743701935, 40.7682282835967]";
	std::string line7 = "] ] ] } }]}";





	std::ofstream myfile;
	myfile.open("example.geojson");
	myfile << line1 << "\n";
	myfile << line2 << "\n";
	myfile << line3 << "\n";
	myfile << line4 << "\n";
	myfile << line5 << "\n";



//	float initialLongttitude = -73.98397743701935;
//	float initialLatitude = 40.7682282835967;
	for (int i = 1; i < m_poly.size(); ++i) {
		int currentX = m_poly[i].x();
		int currentY = m_poly[i].y();

		float earhRadius = 6378137;




		int distX = currentX - m_poly[i - 1].x();
		int distY = -(currentY - m_poly[i - 1].y());
		std::cout << "disttance X " << distX << std::endl;
		std::cout << "distance Y " << distY << std::endl;
		float scalePerOneMeter =(float) 1.0 /(float) 111111.0;
		//std::cout << std::setprecision(10);
		std::cout << "scalePerMeter " << scalePerOneMeter << std::endl;
		std::cout << "Scale Value from GUI " << m_scaleValueX << std::endl;



	//	dLat = dn / R
	//		dLon = de / (R*Cos(Pi*lat / 180))



		float scaleX = (float)distX / (float)m_scaleValueX; // 2.8;
		float scaleY = (float)distY / (float)m_scaleValueY; //3.65;

		//float longtitudeX = scaleX / (earhRadius * std::cos(3.14*40.7682282835967/180)) ;
		//float lantitudeY = scaleY / earhRadius;
		std::cout << "Scaled by meter X " << scaleX << std::endl;
		std::cout << "Scaled by meter Y " << scaleY << std::endl;


	     float longtitudeX = scaleX * scalePerOneMeter/0.9999999;
		float lantitudeY = scaleY * scalePerOneMeter;


	

		float newLong = initialLongttitude + longtitudeX;
		float newLat = initialLatitude + lantitudeY;
		std::cout << std::setprecision(10);
		std::cout << "PRINT Longtitude " << newLong << std::endl;
		std::cout << std::setprecision(10);
		std::cout << "Print Latitude  " << newLat << std::endl;

		std::string tmpLine = "[" + std::to_string(newLong) + "," + " " + std::to_string(newLat) + "]";
		if (i != m_poly.size() - 1) {
			tmpLine = tmpLine + ",";
		}
		std::cout << "Final line before writng into filee " << tmpLine << std::endl;
		myfile << tmpLine << "\n";
		initialLongttitude = newLong;
		initialLatitude = newLat;



	}

	

	//myfile << line6 << "\n";
	myfile << line7 << "\n";
	myfile.close();  */
}



void FloorPlanSegmentationGui::calculateLatAndLong(const float& initLat, const float& initLong, const float&  meterPerX, const float& meterPerY, float& finalLat, float& finalLong)
{


	

	//Earths radius, sphere
 //   float R = 6378137;
	
	float R = 6371000;
	//offsets in meters



	float de = meterPerX;// 62.5;
	float dn = meterPerY;//  110.96;

						 //Coordinate offsets in radians
	float dLat = dn / R;
	float dLon = de / (R*std::cos(PI*initLat / 180));

	//OffsetPosition, decimal degrees
	finalLat = initLat + dLat * 180 / PI;
	finalLong = initLong + dLon * 180 / PI;


}




void FloorPlanSegmentationGui::drawHeightMapValue()
{
	QPoint tmpMovePoint  = m_mainGraphicsScene->transferMovedPointsPosition();
	//m_graphicsTextItem->setRect(tmpMovePoint.x(), tmpMovePoint.y(),10,10);
	//m_mainGraphicsScene->addItem(m_graphicsTextItem);
	m_graphicsTextItem->setPos(tmpMovePoint.x(), tmpMovePoint.y());
	m_graphicsTextItem->setScale(2);
	QString tmpPositon = QString(std::to_string(tmpMovePoint.x()).c_str()) + "  " +  QString(std::to_string(tmpMovePoint.y()).c_str());
	if (tmpMovePoint.x() < m_image.width() && tmpMovePoint.y() < m_image.height()  /*&&  m_roomTypeComboBoBox->currentText() == "HeightMap"*/) {
		cv::Mat heightMap;
		cv::Mat sinrMap;
		if (m_DbmShowingButton->isChecked()  /*&&  parseHeightMapTxtFile(heightMap,sinrMap) */) {
			std::cout << "CALLED DBM SHOW BUTTON \n";
			if (m_heightMapInitImage.rows == m_image.height() && m_heightMapInitImage.cols == m_image.width() ) {
				std::cout << "FINAL HEIGHTMAPPPPPPPPPPPPPPPPPPP \n";
				//m_graphicsTextItem->setRect(tmpMovePoint.x(), tmpMovePoint.y(),10,10);
				tmpPositon = QString(std::to_string(m_heightMapInitImage.at<int>(tmpMovePoint.y(), tmpMovePoint.x())).c_str()) + " Dbm";
				m_graphicsTextItem->setPlainText(tmpPositon);
				//m_graphicsTextItem->setItemTitle
				m_mainGraphicsScene->addItem(m_graphicsTextItem);
				//std::cout << m_roomTypeComboBoBox->currentText().toStdString() << std::endl;
			}
		}
		else if (m_SinrShowingButton->isChecked() /*&& parseHeightMapTxtFile(heightMap, sinrMap)*/) {
			if (m_sinrInitImage.rows == m_image.height() && m_sinrInitImage.cols == m_image.width()) {
				std::cout << "FINAL HEIGHTMAPPPPPPPPPPPPPPPPPPP  SINR\n";
				//m_graphicsTextItem->setRect(tmpMovePoint.x(), tmpMovePoint.y(),10,10);
				tmpPositon = QString(std::to_string(m_sinrInitImage.at<float>(tmpMovePoint.y(), tmpMovePoint.x())).c_str()) + " DB";
				m_graphicsTextItem->setPlainText(tmpPositon);
				//m_graphicsTextItem->setItemTitle
				m_mainGraphicsScene->addItem(m_graphicsTextItem);
				//std::cout << m_roomTypeComboBoBox->currentText().toStdString() << std::endl;
			}
		}
		else if (!m_SinrShowingButton->isChecked() && !m_DbmShowingButton->isChecked()) {
			m_mainGraphicsScene->removeItem(m_graphicsTextItem);
		}
		
	//	std::cout << m_roomTypeComboBoBox->currentText().toStdString() << "\n";

//		m_graphicsTextItem->setPlainText(tmpPositon);
//		m_mainGraphicsScene->addItem(m_graphicsTextItem);
		//std::cout << m_roomTypeComboBoBox->currentText().toStdString() << std::endl;
	}
	else {

		QList<QGraphicsItem*> all = m_mainGraphicsScene->items();

		std::cout << "After getting items " << all.size() << " \n";
		//m_mainGraphicsScene->clear();
		//if (all.size() > 0) {
		for (int i = 0; i < all.size(); i++)
		{
			QGraphicsItem *gi = all[i];
			QGraphicsTextItem* tmpItem = dynamic_cast<QGraphicsTextItem*>(gi);
			if (tmpItem) {
				m_mainGraphicsScene->removeItem(gi);
				//delete gi;
				m_mainGraphicsScene->update();
			}
		}
	//	tmpPositon = QString("-90") + QString(" Dbm");
	//	m_graphicsTextItem->setPlainText(tmpPositon);
	//	m_mainGraphicsScene->addItem(m_graphicsTextItem);
	}




}

bool FloorPlanSegmentationGui::eventFilter(QEvent *event)
{
	if (event->type() == QEvent::Close) {
		emit WidgetClosed();
		event->accept();
		//coloringOfSelectedPolygonSlot();
		m_poly.clear();
	}
	return false;
}


/*
bool FloorPlanSegmentationGui::eventFilter(QObject * obj, QEvent * ev)
{
	if (obj == m_mainGraphicsView)
		if (ev->type() == QEvent::MouseMove)
		{
			QMouseEvent *mEvent = (QMouseEvent*)ev;
			qDebug() << "Mouse move event!!!!!!!!!!!!!!!";
		}
	return false;
}
*/






void FloorPlanSegmentationGui::coloringOfSelectedWalls()
{
	QBrush brush;
	brush.setColor(Qt::green);
	
	brush.setStyle(Qt::SolidPattern);
	QPen pen(Qt::green);


	if (m_roomColorComboBox->currentText() == "Red") {
		brush.setColor(Qt::red);
		pen.setColor(Qt::red);
	}
	else if (m_roomColorComboBox->currentText() == "Green") {
		brush.setColor(Qt::green);
		pen.setColor(Qt::green);
	}
	else if (m_roomColorComboBox->currentText() == "Yellow") {
		brush.setColor(Qt::yellow);
		pen.setColor(Qt::yellow);
	}
	else if (m_roomColorComboBox->currentText() == "Blue") {
		brush.setColor(Qt::blue);
		pen.setColor(Qt::blue);
	}
	else if (m_roomColorComboBox->currentText() == "Black") {
		brush.setColor(Qt::black);
		pen.setColor(Qt::black);
	}
	else if (m_roomColorComboBox->currentText() == "Gray") {
		brush.setColor(Qt::gray);
		pen.setColor(Qt::gray);
	}
	else if (m_roomColorComboBox->currentText() == "DarkRed") {
		brush.setColor(Qt::darkRed);
		pen.setColor(Qt::darkRed);
	}
	else if (m_roomColorComboBox->currentText() == "DarkGreen") {
		brush.setColor(Qt::darkGreen);
		pen.setColor(Qt::darkGreen);
	}
	else if (m_roomColorComboBox->currentText() == "DarkBlue") {
		brush.setColor(Qt::darkBlue);
		pen.setColor(Qt::darkBlue);
	}
	else if (m_roomColorComboBox->currentText() == "DarkYellow") {
		brush.setColor(Qt::darkYellow);
		pen.setColor(Qt::darkYellow);
	}

	pen.setBrush(brush);
	pen.setWidth(5);
	for (int i = 0; i < m_poly.size()-1; ++i) {
		QLineF tmpLine;
		tmpLine.setLine(m_poly[i].x(), m_poly[i].y(), m_poly[i + 1].x(), m_poly[i + 1].y());
		//tmpLine.y1 = m_poly[i].y();
	//	tmpLine.x2 = m_poly[i+1].x();
		//tmpLine.y2 = m_poly[i+1].y();
		m_mainGraphicsScene->addLine(tmpLine, pen);
	}

}


void FloorPlanSegmentationGui::coloringOfSelectedPolygonSlot()
{
	std::cout << "Final coloring stuff \n";
	QBrush brush;
	QPen pen;
	//if (if  m_) {

	//}
	if (m_roomColorComboBox->currentText() == "Red") {
		brush.setColor(Qt::red);
		pen.setColor(Qt::red);
	}
	else if (m_roomColorComboBox->currentText() == "Green") {
		brush.setColor(Qt::green);
		pen.setColor(Qt::green);
	}
	else if (m_roomColorComboBox->currentText() == "Yellow") {
		brush.setColor(Qt::yellow);
		pen.setColor(Qt::yellow);
	}
	else if (m_roomColorComboBox->currentText() == "Blue") {
		brush.setColor(Qt::blue);
		pen.setColor(Qt::blue);
	}
	else if (m_roomColorComboBox->currentText() == "Black") {
		brush.setColor(Qt::black);
		pen.setColor(Qt::black);
	}
	else if (m_roomColorComboBox->currentText() == "Gray") {
		brush.setColor(Qt::gray);
		pen.setColor(Qt::gray);
	}
	else if (m_roomColorComboBox->currentText() == "DarkRed") {
		brush.setColor(Qt::darkRed);
		pen.setColor(Qt::darkRed);
	}
	else if (m_roomColorComboBox->currentText() == "DarkGreen") {
		brush.setColor(Qt::darkGreen);
		pen.setColor(Qt::darkGreen);
	}
	else if (m_roomColorComboBox->currentText() == "DarkBlue") {
		brush.setColor(Qt::darkBlue);
		pen.setColor(Qt::darkBlue);
	}
	else if (m_roomColorComboBox->currentText() == "DarkYellow") {
		brush.setColor(Qt::darkYellow);
		pen.setColor(Qt::darkYellow);
	}

	brush.setStyle(Qt::SolidPattern);	
	m_mainGraphicsScene->addPolygon(m_poly, pen, brush);
	
	m_poly.clear();

}


void FloorPlanSegmentationGui::onRemoveLastSelectedPoint()
{
	std::cout << "Calling remove last item function \n";
	if (m_selectComponentWidget->currentText() != "HeightMap" &&  m_selectComponentWidget->currentText() != "Geojson") {
		if (m_elipseItemsVec.size() > 0) {
			m_poly.pop_back();
			m_mainGraphicsScene->removeItem(m_elipseItemsVec[m_elipseItemsVec.size() - 1]);
			m_elipseItemsVec.pop_back();
			m_mainGraphicsScene->update();
		}
	}
	else if (m_selectComponentWidget->currentText() == "Geojson") {

	}
	else {
	//	m_mainGraphicsScene->removeItem(m_graphicsRectItem);
		QGraphicsRectItem* graphicsRectItem = new QGraphicsRectItem;
		//QGraphicsEllipseItem* elipseItemForAxisPoint =  new QGraphicsEllipseItem;
		


		QRectF tmpRect;
		
		QPoint selectedPoint = m_mainGraphicsScene->transferPickedPointsPosition();



		std::string imageSizeFileName = "imageSize.txt";
		std::ofstream fileSize;
		fileSize.open(imageSizeFileName,std::ios::app);
		fileSize << m_image.width() << " " << m_image.height() << " " << selectedPoint.x() << " " << selectedPoint.y() << "\n";
		fileSize.close();
		m_isSelectedAxisPoint = true;


		tmpRect.setX(selectedPoint.x());
		tmpRect.setY (selectedPoint.y());
		tmpRect.setWidth(20);
		tmpRect.setHeight(10);
	////	m_graphicsRectItem->setRect(tmpRect);
	


		m_elipseItemForAxisPoint = NULL;
		delete m_elipseItemForAxisPoint;
		m_elipseItemForAxisPoint = new QGraphicsEllipseItem;



		m_elipseItemForAxisPoint->setRect(selectedPoint.x(), selectedPoint.y(), 20, 20);
		//elipseItemForAxisPoint->set
		graphicsRectItem->setRect(tmpRect);
	


		QBrush brush;
		brush.setColor(Qt::blue);
		brush.setStyle(Qt::SolidPattern);

		QPen pen(Qt::blue);
		pen.setBrush(brush);
		pen.setWidth(5);
		//QLineF tmpLine;
		////m_graphicsRectItem->setPen(pen);
		graphicsRectItem->setPen(pen);

		
	


		m_elipseItemForAxisPoint->setPen(pen);
		m_elipseItemForAxisPoint->setBrush(brush);


		///m_mainGraphicsScene->addItem(m_graphicsRectItem);
		m_mainGraphicsScene->addItem(m_elipseItemForAxisPoint);
		m_mainGraphicsScene->update();
	}

	

}


void FloorPlanSegmentationGui::dbmShowingSlot()
{

	if (!m_isDbmBoxChecked) {
		m_DbmShowingButton->setChecked(true);
		m_SinrShowingButton->setChecked(false);
		m_isDbmBoxChecked = true;
		this->update();
		
	}
	else {
		m_isDbmBoxChecked = false;
		m_DbmShowingButton->setChecked(false);
		this->update();
	}
	/*if (m_DbmShowingButton->isChecked()) {
		m_DbmShowingButton->setChecked(false);
	}
	else {
		m_DbmShowingButton->setChecked(true);
	}
	m_SinrShowingButton->setChecked(false);*/
}


void FloorPlanSegmentationGui::sinrShowingSlot()
{

	if (!m_isSinrBoxChecked) {
		m_SinrShowingButton->setChecked(true);
		m_DbmShowingButton->setChecked(false);
		m_isSinrBoxChecked = true;
		this->update();
	}
	else {
		m_isSinrBoxChecked = false;
		m_SinrShowingButton->setChecked(false);
		this->update();
	}

	/*m_DbmShowingButton->setChecked(false);
	
	if (m_SinrShowingButton->isChecked()) {
		m_SinrShowingButton->setChecked(false);
	} else {
		m_SinrShowingButton->setChecked(true);
	}*/
//	m_SinrShowingButton->setChecked(true);
}




void FloorPlanSegmentationGui::removingSelectedPointsSlot()
{
	;
}



FloorPlanSegmentationGui::~FloorPlanSegmentationGui()
{

}
